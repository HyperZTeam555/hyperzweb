<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>HyperZWeb</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <style>
        :root {
            --bg-main: #02030a;
            --bg-elevated: #070a16;
            --accent: #00b4ff;
            --accent-soft: #00b4ff55;
            --accent-strong: #00e0ff;
            --border-subtle: #1a2238;
            --text-main: #f5f7ff;
            --text-soft: #a9b3d9;
            --danger: #ff4b81;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            background: radial-gradient(circle at top, #071021 0, #02030a 55%, #000 100%);
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            color: var(--text-main);
            overflow: hidden;
        }

        .topbar {
            width: 100%;
            height: 80px;
            background: linear-gradient(90deg, #050816, #050816, #02030a);
            display: flex;
            align-items: center;
            position: relative;
            border-bottom: 1px solid var(--border-subtle);
            box-shadow: 0 10px 30px #000000aa;
        }

        .logo-wrap {
            position: absolute;
            left: 32px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .logo-icon {
            width: 26px;
            height: 26px;
            border-radius: 8px;
            background: radial-gradient(circle at 30% 20%, #00e0ff, #0066ff);
            box-shadow: 0 0 18px #00b4ffaa;
        }

        .logo {
            font-size: 22px;
            font-weight: 700;
            letter-spacing: 1.5px;
            color: var(--accent-strong);
            text-shadow: 0 0 12px #00b4ff88;
        }

        #hackersim-password-wrapper {
            display: inline-table;
            margin: 0 auto;
            width: auto;
        }

        #hackersim-password-display {
            color: var(--accent);
            font-size: 20px;
            font-family: monospace;
            font-weight: 700;
            letter-spacing: 4px;
            height: auto;
            display: table-cell;
            white-space: nowrap;
            margin: 0;
            padding: 0;
            width: auto;
        }

        .center-wrap {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }

        .center-buttons {
            display: flex;
            gap: 24px;
            align-items: center;
        }

        .center-buttons button {
            background: transparent;
            border-radius: 999px;
            border: 1px solid transparent;
            color: var(--text-soft);
            font-size: 16px;
            padding: 8px 18px;
            cursor: pointer;
            transition: 0.2s;
        }

        .center-buttons button:hover {
            color: var(--accent-strong);
            border-color: var(--accent-soft);
            background: #0a1020;
            box-shadow: 0 0 12px #00b4ff44;
        }

        .search-btn {
            width: 42px;
            height: 42px;
            border-radius: 999px;
            border: 1px solid var(--accent-soft);
            background: radial-gradient(circle at 30% 20%, #071427, #02030a);
            cursor: pointer;
            position: absolute;
            top: 50%;
            right: 32px;
            transform: translateY(-50%);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: 0.2s;
            box-shadow: 0 0 12px #00b4ff33;
        }

        .search-btn .circle {
            width: 14px;
            height: 14px;
            border: 2px solid var(--accent-strong);
            border-radius: 50%;
        }

        .search-btn .handle {
            width: 3px;
            height: 10px;
            background: var(--accent-strong);
            position: absolute;
            transform: translate(6px, 6px) rotate(45deg);
        }

        .search-btn.active .circle {
            width: 22px;
            height: 2px;
            border: none;
            background: var(--accent-strong);
            transform: rotate(45deg);
        }

        .search-btn.active .handle {
            width: 22px;
            height: 2px;
            background: var(--accent-strong);
            transform: rotate(-45deg);
        }

        .search-btn:hover {
            box-shadow: 0 0 18px #00b4ff88;
            transform: translateY(-50%) scale(1.05);
            border-color: var(--accent-strong);
        }

        .search-panel {
            position: fixed;
            top: 80px;
            right: -100%;
            width: 100%;
            height: 80px;
            background: linear-gradient(90deg, #050816ee, #02030aee);
            border-bottom: 1px solid var(--border-subtle);
            display: flex;
            align-items: center;
            padding: 0 32px;
            transition: 0.35s ease;
            z-index: 20;
        }

        .search-panel.active {
            right: 0;
        }

        .search-panel input {
            width: 100%;
            height: 44px;
            border-radius: 999px;
            border: 1px solid var(--accent-soft);
            background: #02030a;
            color: var(--text-main);
            padding: 0 18px;
            font-size: 15px;
            outline: none;
        }

        .search-panel input::placeholder {
            color: #6f7aa5;
        }

        .search-panel input:focus {
            border-color: var(--accent-strong);
            box-shadow: 0 0 18px #00b4ff55;
        }

        #zweb, #games, #chatbot {
            display: none;
            height: calc(100vh - 80px);
            background: radial-gradient(circle at top, #050816 0, #02030a 55%, #000 100%);
        }

        #zweb {
            display: flex;
            flex-direction: column;
        }

        #tabs {
            height: 42px;
            background: #050816;
            border-bottom: 1px solid var(--border-subtle);
            display:flex;
            align-items:center;
            padding:0 10px;
            overflow-x:auto;
            white-space:nowrap;
        }

        .tab {
            padding: 5px 12px;
            background:#070a16;
            border:1px solid var(--border-subtle);
            border-radius:999px;
            cursor:pointer;
            color:var(--text-soft);
            font-size: 13px;
            display:inline-flex;
            align-items:center;
            margin-right:8px;
        }

        .tab.active {
            background: radial-gradient(circle at 30% 0, #00e0ff, #0066ff);
            color:#02030a;
            border-color: transparent;
            box-shadow: 0 0 14px #00b4ff88;
        }

        .tab .close-btn {
            font-weight:bold;
            cursor:pointer;
            padding:0 4px;
            margin-left:6px;
        }

        .new-tab-btn {
            padding: 5px 12px;
            background:#0b1224;
            color:var(--accent-strong);
            border-radius:999px;
            cursor:pointer;
            font-weight:bold;
            border:1px dashed var(--accent-soft);
            display:inline-block;
        }

        #zweb-url-bar {
            height:50px;
            background:#050816;
            border-bottom:1px solid var(--border-subtle);
            display:flex;
            align-items:center;
            padding:0 12px;
            gap:10px;
        }

        #zweb-url {
            flex:1;
            height:36px;
            border-radius:999px;
            border:1px solid var(--border-subtle);
            background:#02030a;
            color:var(--text-main);
            padding:0 14px;
            font-size:14px;
            outline:none;
        }

        #zweb-url:focus {
            border-color: var(--accent-soft);
        }

        #zweb-frame {
            width:100%;
            height: calc(100% - 92px);
            border:none;
            background:#02030a;
        }

        .btn-go {
            height:36px;
            padding:0 16px;
            background: radial-gradient(circle at 30% 0, #00e0ff, #0066ff);
            border:none;
            border-radius:999px;
            font-weight:600;
            cursor:pointer;
            color:#02030a;
            box-shadow: 0 0 14px #00b4ff88;
        }

        #games {
            padding: 24px 32px;
            box-sizing: border-box;
            overflow-y: auto;
        }

        .games-container {
            display: flex;
            gap: 24px;
            flex-wrap: wrap;
        }

        .game-card {
            background: radial-gradient(circle at top, #0b1024, #050816);
            border:1px solid var(--border-subtle);
            border-radius:18px;
            padding:18px 18px 16px;
            width: 260px;
            box-shadow: 0 18px 40px #000000aa;
            position: relative;
            overflow: hidden;
        }

        .game-card::before {
            content:"";
            position:absolute;
            inset:-40%;
            background: radial-gradient(circle at 0 0, #00b4ff33, transparent 55%);
            opacity:0.7;
            pointer-events:none;
        }

        .game-card h2 {
            margin:0 0 6px;
            color:var(--accent-strong);
            font-size:18px;
        }

        .game-card p {
            margin:0;
            color:var(--text-soft);
            font-size:13px;
        }

        .btn-small {
            margin-top:14px;
            padding:7px 14px;
            background: radial-gradient(circle at 30% 0, #00e0ff, #0066ff);
            border:none;
            border-radius:999px;
            cursor:pointer;
            font-weight:600;
            color:#02030a;
            font-size:13px;
            box-shadow: 0 0 14px #00b4ff88;
        }

        #game-overlay {
            position: fixed;
            top: 80px;
            left: 0;
            width: 100%;
            height: calc(100vh - 80px);
            background: radial-gradient(circle at top, #050816f0, #02030af0);
            display: none;
            z-index: 25;
            box-sizing: border-box;
            padding: 10px 10px 16px;
        }

        #game-close {
            position: absolute;
            top: 12px;
            left: 16px;
            width: 32px;
            height: 32px;
            border-radius: 999px;
            border: 1px solid var(--border-subtle);
            background:#050816;
            color:var(--text-soft);
            font-weight:bold;
            cursor:pointer;
        }

        .game-inner {
            width: 100%;
            height: 100%;
            display:none;
            box-sizing:border-box;
            padding-top: 40px;
        }

        .game-header {
            text-align:center;
            margin-bottom:8px;
        }

        .game-header h2 {
            margin:0;
            font-size:22px;
            letter-spacing:1px;
        }

        .game-options {
            text-align:center;
            margin-bottom:10px;
        }

        .game-options label {
            font-size:13px;
            color:var(--text-soft);
            margin-right:6px;
        }

        .game-options select {
            background:#02030a;
            color:var(--text-main);
            border:1px solid var(--border-subtle);
            border-radius:999px;
            padding:5px 10px;
            font-size:13px;
        }

        .board {
            display:grid;
            gap:4px;
            margin-top:10px;
            justify-content:center;
        }

        .board.tictactoe {
            grid-template-columns: repeat(3, 80px);
            grid-template-rows: repeat(3, 80px);
        }

        .board.reversi {
            grid-template-columns: repeat(8, 40px);
            grid-template-rows: repeat(8, 40px);
        }

        .board.minesweeper {
            grid-template-columns: repeat(10, 32px);
            grid-template-rows: repeat(10, 32px);
        }

        .cell {
            background:#02030a;
            border:1px solid var(--border-subtle);
            display:flex;
            align-items:center;
            justify-content:center;
            font-size:28px;
            cursor:pointer;
            border-radius:10px;
        }

        .cell.reversi-cell {
            font-size:20px;
        }

        .cell.minesweeper-cell {
            font-size:14px;
            font-weight:600;
            background:#0a1020;
            border:1px solid #2a3a5a;
        }

        .cell.minesweeper-cell:hover {
            background:#0f1530;
            border-color:var(--accent-soft);
        }

        .cell.minesweeper-cell.revealed {
            background:#050816;
            cursor:default;
            border:1px solid var(--border-subtle);
        }

        .cell.minesweeper-cell.flagged {
            color:var(--danger);
        }

        .cell.minesweeper-cell.mine {
            color:var(--danger);
        }

        .status {
            margin-top:10px;
            min-height:20px;
            text-align:center;
            font-size:13px;
            color:var(--text-soft);
        }

        #game-pong {
            display:flex;
            flex-direction:column;
            align-items:center;
        }

        #pong-canvas {
            background:#02030a;
            border:1px solid var(--border-subtle);
            border-radius:18px;
            display:block;
            margin:0 auto;
            box-shadow: 0 18px 40px #000000aa;
        }

        #pong-status {
            text-align:center;
            margin-top:10px;
            font-size:13px;
            color:var(--text-soft);
        }

        #chatbot {
            display:flex;
            flex-direction:column;
            height:calc(100vh - 80px);
            padding:12px 16px;
            box-sizing:border-box;
            gap:12px;
        }

        #chat-log {
            flex:1;
            min-height:0;
            max-height:calc(100% - 40px);
            border-radius:18px;
            padding:14px;
            overflow:hidden;
            overflow-y:scroll;
            background: radial-gradient(circle at top, #050816, #02030a);
            border:1px solid var(--border-subtle);
            box-shadow: 0 18px 40px #000000aa inset;
            scrollbar-color: var(--accent-soft) transparent;
            scrollbar-width: thin;
        }

        #chat-log::-webkit-scrollbar {
            width: 14px;
        }

        #chat-log::-webkit-scrollbar-track {
            background: rgba(26, 34, 56, 0.3);
            border-radius: 10px;
        }

        #chat-log::-webkit-scrollbar-thumb {
            background: var(--accent-soft);
            border-radius: 7px;
            min-height: 40px;
        }

        #chat-log::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
        }

        .chat-msg {
            margin-bottom:10px;
            max-width:70%;
            padding:8px 11px;
            border-radius:14px;
            font-size:13px;
            line-height:1.4;
            word-wrap:break-word;
        }

        .chat-msg.user {
            margin-left:auto;
            background: radial-gradient(circle at 30% 0, #00e0ff, #0066ff);
            color:#02030a;
            border-bottom-right-radius:4px;
        }

        .chat-msg.bot {
            margin-right:auto;
            background:#050816;
            color:var(--text-main);
            border:1px solid var(--border-subtle);
            border-bottom-left-radius:4px;
        }

        .chat-label {
            font-weight:600;
            font-size:11px;
            opacity:0.8;
            margin-bottom:2px;
        }

        #chat-input-bar {
            display:flex;
            gap:10px;
            flex-shrink:0;
        }

        #chat-input {
            flex:1;
            height:40px;
            border-radius:999px;
            border:1px solid var(--border-subtle);
            background:#02030a;
            color:var(--text-main);
            padding:0 14px;
            font-size:14px;
            outline:none;
        }

        #chat-input:focus {
            border-color:var(--accent-soft);
        }

        #chat-send {
            width:96px;
            border-radius:999px;
            border:none;
            background: radial-gradient(circle at 30% 0, #00e0ff, #0066ff);
            color:#02030a;
            font-weight:600;
            cursor:pointer;
            font-size:14px;
            box-shadow: 0 0 14px #00b4ff88;
        }

        .tile-2048 {
            background: #3a4a6a;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            font-weight: 700;
            color: #f5f7ff;
            transition: all 0.15s ease-in-out;
            position: relative;
        }

        .tile-2048.slide {
            animation: slideIn 0.15s ease-in-out;
        }

        .tile-2048.merge {
            animation: mergeScale 0.15s ease-in-out;
        }

        @keyframes slideIn {
            0% {
                opacity: 0.7;
                transform: scale(0.95);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes mergeScale {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.15);
            }
            100% {
                transform: scale(1);
            }
        }

        .tile-2048.empty {
            background: #050816;
            color: transparent;
        }

        .tile-2048[data-value="2"] { background: #3a4a6a; }
        .tile-2048[data-value="4"] { background: #4a5a7a; }
        .tile-2048[data-value="8"] { background: #5a6a8a; color: #f5f7ff; }
        .tile-2048[data-value="16"] { background: #6a7a9a; }
        .tile-2048[data-value="32"] { background: #00b4ff; }
        .tile-2048[data-value="64"] { background: #00e0ff; color: #02030a; }
        .tile-2048[data-value="128"] { background: #00ff88; color: #02030a; font-size: 28px; }
        .tile-2048[data-value="256"] { background: #ffff00; color: #02030a; }
        .tile-2048[data-value="512"] { background: #ffaa00; color: #02030a; }
        .tile-2048[data-value="1024"] { background: #ff6600; color: #f5f7ff; font-size: 28px; }
        .tile-2048[data-value="2048"] { background: #ff4b81; color: #f5f7ff; font-size: 24px; font-weight: 900; }
        .tile-2048[data-value="4096"] { background: #ff0066; color: #f5f7ff; font-size: 24px; }
        .tile-2048[data-value="8192"] { background: #cc0044; color: #f5f7ff; font-size: 24px; }

        .board.checkers {
            grid-template-columns: repeat(8, 40px);
            grid-template-rows: repeat(8, 40px);
        }

        .board.chess {
            grid-template-columns: repeat(8, 50px);
            grid-template-rows: repeat(8, 50px);
        }

        .cell.chess-cell {
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 32px;
            border: 1px solid var(--border-subtle);
            border-radius: 8px;
        }

        .cell.chess-cell.light {
            background: #0a1020;
            border: 1px solid #2a3a5a;
        }

        .cell.chess-cell.dark {
            background: #050816;
            border: 1px solid var(--border-subtle);
        }

        .cell.chess-cell:hover {
            border-color: var(--accent-soft);
        }

        .cell.chess-cell.selected {
            background: #00e0ff !important;
            border-color: #00e0ff !important;
            box-shadow: 0 0 12px #00b4ff44;
        }

        .cell.chess-cell.highlight {
            background: #00ff88 !important;
            border-color: #00ff88 !important;
            opacity: 0.9;
        }

        .checkers-square {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 20px;
            position: relative;
            border: 1px solid var(--border-subtle);
            border-radius: 8px;
        }

        .checkers-square.light {
            background: #0a1020;
            border: 1px solid #2a3a5a;
        }

        .checkers-square.dark {
            background: #050816;
            border: 1px solid var(--border-subtle);
        }

        .checkers-square.selected {
            background: #00e0ff !important;
            border-color: #00e0ff !important;
            box-shadow: 0 0 12px #00b4ff44;
        }

        .checkers-square.highlight {
            background: #00ff88 !important;
            border-color: #00ff88 !important;
            opacity: 0.9;
        }

        .checkers-square:hover {
            border-color: var(--accent-soft);
        }

        .checkers-piece {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            cursor: pointer;
            border: 2px solid transparent;
        }

        .checkers-piece.red {
            background: linear-gradient(135deg, #ff4b81, #ff1744);
            color: white;
            border-color: #cc0044;
            box-shadow: 0 4px 8px rgba(255, 27, 68, 0.3), inset 0 -2px 4px rgba(0,0,0,0.3);
        }

        .checkers-piece.black {
            background: linear-gradient(135deg, #333, #000);
            color: #00ff88;
            border-color: #111;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5), inset 0 -2px 4px rgba(0,0,0,0.3);
        }

        .checkers-piece.king {
            font-weight: 900;
        }

        .board.connect4 {
            grid-template-columns: repeat(7, 50px);
            grid-template-rows: repeat(6, 50px);
            gap: 4px;
        }

        .cell.connect4-cell {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: #0a1020;
            border: 1px solid #2a3a5a;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .cell.connect4-cell:hover {
            background: #0f1530;
            border-color: var(--accent-soft);
            box-shadow: 0 0 8px #00b4ff33;
        }

        .connect4-piece {
            width: 42px;
            height: 42px;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3), inset 0 -2px 4px rgba(0,0,0,0.3);
        }

        .connect4-piece.falling {
            animation: dropPiece 0.5s ease-in;
        }

        @keyframes dropPiece {
            0% {
                transform: translate(-50%, -150%);
                opacity: 0;
            }
            100% {
                transform: translate(-50%, -50%);
                opacity: 1;
            }
        }

        .connect4-piece.red {
            background: linear-gradient(135deg, #ff4b81, #ff1744);
            border: 2px solid #cc0044;
        }

        .connect4-piece.yellow {
            background: linear-gradient(135deg, #ffff00, #ffdd00);
            border: 2px solid #ffaa00;
            color: #333;
        }

        .connect4-piece.winner {
            animation: winPulse 0.6s ease-in-out;
        }

        @keyframes winPulse {
            0%, 100% {
                transform: translate(-50%, -50%) scale(1);
            }
            50% {
                transform: translate(-50%, -50%) scale(1.2);
            }
        }
    </style>
</head>
<body>

    <div class="topbar">
        <div class="logo-wrap">
            <div class="logo">HyperZWeb</div>
        </div>

        <div class="center-wrap">
            <div class="center-buttons">
                <button onclick="showSection('zweb')">ZWeb</button>
                <button onclick="showSection('games')">Games</button>
                <button onclick="showSection('chatbot')">HyperZAI</button>
            </div>
        </div>

        <button class="search-btn" id="searchBtn">
            <div class="circle"></div>
            <div class="handle"></div>
        </button>
    </div>

    <div class="search-panel" id="searchPanel">
        <input type="text" id="searchInput" placeholder="Search games or ask HyperZAI...">
    </div>

    <div id="zweb">
        <div id="tabs">
            <div class="new-tab-btn" onclick="createTab()">+</div>
        </div>

        <div id="zweb-url-bar">
            <input id="zweb-url" type="text" placeholder="Search or enter URL...">
            <button class="btn-go" onclick="zwebNavigate()">Go</button>
        </div>

        <iframe id="zweb-frame" src="about:blank"></iframe>

        <div id="hyperzsearch" style="display:none; padding:20px; color:white; overflow-y:auto; height:calc(100vh - 80px);">
            <h2 style="color:#00e0ff; margin-top:0;">HyperZSearch Results</h2>
            <div id="hyperzsearch-results"></div>
        </div>
    </div>

    <div id="games">
        <div class="games-container">
            <div class="game-card">
                <h2>Tic Tac Toe</h2>
                <p>2 Player or Bot with multiple difficulties.</p>
                <button class="btn-small" onclick="openGame('ttt')">Play</button>
            </div>

            <div class="game-card">
                <h2>Reversi</h2>
                <p>Classic Othello-style, 2P or Bot with levels.</p>
                <button class="btn-small" onclick="openGame('rev')">Play</button>
            </div>

            <div class="game-card">
                <h2>Pong</h2>
                <p>2 Player or Bot, first to 10 points.</p>
                <button class="btn-small" onclick="openGame('pong')">Play</button>
            </div>

            <div class="game-card">
                <h2>Snake</h2>
                <p>Classic Snake with arrow keys.</p>
                <button class="btn-small" onclick="openGame('snake')">Play</button>
            </div>

            <div class="game-card">
                <h2>Minesweeper</h2>
                <p>Find all safe squares and avoid the mines.</p>
                <button class="btn-small" onclick="openGame('minesweeper')">Play</button>
            </div>

            <div class="game-card">
                <h2>2048</h2>
                <p>Slide tiles to combine numbers and reach 2048.</p>
                <button class="btn-small" onclick="openGame('2048')">Play</button>
            </div>

            <div class="game-card">
                <h2>Flappy Bird</h2>
                <p>Tap to fly, avoid the pipes and obstacles.</p>
                <button class="btn-small" onclick="openGame('flappybird')">Play</button>
            </div>

            <div class="game-card">
                <h2>Checkers</h2>
                <p>Classic board game with AI bot difficulties.</p>
                <button class="btn-small" onclick="openGame('checkers')">Play</button>
            </div>

            <div class="game-card">
                <h2>Connect Four</h2>
                <p>Get 4 in a row, play vs AI or 2-player.</p>
                <button class="btn-small" onclick="openGame('connect4')">Play</button>
            </div>

            <div class="game-card">
                <h2>Chess</h2>
                <p>Classic strategy game with AI difficulties.</p>
                <button class="btn-small" onclick="openGame('chess')">Play</button>
            </div>

            <div class="game-card">
                <h2>Tetris</h2>
                <p>Classic falling blocks with next preview.</p>
                <button class="btn-small" onclick="openGame('tetris')">Play</button>
            </div>

            <div class="game-card">
                <h2>Codebreaker</h2>
                <p>Crack the 4-digit code in 5 tries.</p>
                <button class="btn-small" onclick="openGame('codebreaker')">Play</button>
            </div>

            <div class="game-card">
                <h2>Block Dash</h2>
                <p>Navigate the grid, collect items, avoid hazards.</p>
                <button class="btn-small" onclick="openGame('gridgame')">Play</button>
            </div>

            <div class="game-card">
                <h2>Hacker Simulator</h2>
                <p>Mine Bitcoin by hacking computers and upgrading power.</p>
                <button class="btn-small" onclick="openGame('hackersim')">Play</button>
            </div>
        </div>
    </div>

    <div id="chatbot">
        <div id="chat-log"></div>
        <div id="chat-input-bar">
            <input id="chat-input" type="text" placeholder="Ask HyperZAI anything, or do math...">
            <button id="chat-send" onclick="chatSend()">Send</button>
        </div>
    </div>

    <div id="game-overlay">
        <button id="game-close" onclick="closeGame()">X</button>

        <div id="game-ttt" class="game-inner">
            <div class="game-header"><h2>Tic Tac Toe</h2></div>
            <div class="game-options">
                <label>Mode:</label>
                <select id="ttt-mode">
                    <option value="2p">2 Player</option>
                    <option value="easy">Easy Bot</option>
                    <option value="medium">Medium Bot</option>
                    <option value="hard">Hard Bot</option>
                    <option value="impossible">Impossible Bot</option>
                </select>
                <button class="btn-small" onclick="tttReset()">Reset</button>
            </div>
            <div id="ttt-board" class="board tictactoe"></div>
            <div id="ttt-status" class="status"></div>
        </div>

        <div id="game-rev" class="game-inner">
            <div class="game-header"><h2>Reversi</h2></div>
            <div class="game-options">
                <label>Mode:</label>
                <select id="rev-mode">
                    <option value="2p">2 Player</option>
                    <option value="easy">Easy Bot</option>
                    <option value="medium">Medium Bot</option>
                    <option value="hard">Hard Bot</option>
                    <option value="impossible">Impossible Bot</option>
                </select>
                <button class="btn-small" onclick="revReset()">Reset</button>
            </div>
            <div id="rev-board" class="board reversi"></div>
            <div id="rev-status" class="status"></div>
        </div>

        <div id="game-pong" class="game-inner">
            <div class="game-header"><h2>Pong</h2></div>
            <div class="game-options">
                <label>Mode:</label>
                <select id="pong-mode">
                    <option value="2p">2 Player</option>
                    <option value="easy">Easy Bot</option>
                    <option value="medium">Medium Bot</option>
                    <option value="hard">Hard Bot</option>
                </select>
                <button class="btn-small" onclick="pongReset()">Reset</button>
            </div>
            <canvas id="pong-canvas" width="640" height="360"></canvas>
            <div id="pong-status" class="status"></div>
        </div>

        <div id="game-snake" class="game-inner">
            <div class="game-header"><h2>Snake</h2></div>
            <div class="game-options">
                <label>Difficulty:</label>
                <select id="snake-difficulty">
                    <option value="easy">Easy (Slower)</option>
                    <option value="medium" selected>Medium (Normal)</option>
                    <option value="hard">Hard (Faster)</option>
                </select>
                <button class="btn-small" onclick="snakeReset()">Reset</button>
            </div>
            <div style="display:flex; flex-direction:column; align-items:center; gap:16px;">
                <canvas id="snake-canvas" width="400" height="400"
                    style="background:#02030a; border:1px solid #1a2238; border-radius:18px; box-shadow:0 18px 40px #000000aa; display:block;">
                </canvas>
                <div id="snake-status" class="status"></div>
            </div>
        </div>

        <div id="game-minesweeper" class="game-inner">
            <div class="game-header"><h2>Minesweeper</h2></div>
            <div class="game-options">
                <label>Difficulty:</label>
                <select id="minesweeper-difficulty">
                    <option value="easy">Easy (10 mines)</option>
                    <option value="medium" selected>Medium (30 mines)</option>
                    <option value="hard">Hard (50 mines)</option>
                </select>
                <button class="btn-small" onclick="minesweaperReset()">Reset</button>
            </div>
            <div id="minesweeper-board" class="board minesweeper"></div>
            <div id="minesweeper-status" class="status"></div>
        </div>

        <div id="game-2048" class="game-inner">
            <div class="game-header"><h2>2048</h2></div>
            <div class="game-options">
                <button class="btn-small" onclick="game2048Reset()">New Game</button>
            </div>
            <div id="2048-container" style="display:flex; flex-direction:column; align-items:center; gap:16px;">
                <div id="2048-score" style="color:var(--accent-strong); font-size:18px; font-weight:600;">Score: 0</div>
                <div id="2048-board" style="display:grid; grid-template-columns:repeat(4,80px); grid-template-rows:repeat(4,80px); gap:8px; background:#0a1020; padding:12px; border-radius:10px; border:1px solid var(--border-subtle);"></div>
            </div>
            <div id="2048-status" class="status"></div>
        </div>

        <div id="game-flappybird" class="game-inner">
            <div class="game-header"><h2>Flappy Bird</h2></div>
            <div class="game-options">
                <button class="btn-small" onclick="flappybirdReset()">New Game</button>
            </div>
            <div style="display:flex; flex-direction:column; align-items:center; gap:16px;">
                <div id="flappybird-score" style="color:var(--accent-strong); font-size:18px; font-weight:600;">Score: 0</div>
                <canvas id="flappybird-canvas" width="320" height="480"
                    style="background: linear-gradient(180deg, #87ceeb 0%, #e0f6ff 100%); border:2px solid var(--accent-soft); border-radius:10px; display:block; cursor:pointer; box-shadow:0 18px 40px #000000aa;">
                </canvas>
            </div>
            <div id="flappybird-status" class="status" style="margin-top:12px;">Click canvas or press SPACE to flap</div>
        </div>

        <div id="game-checkers" class="game-inner">
            <div class="game-header"><h2>Checkers</h2></div>
            <div class="game-options">
                <label>Mode:</label>
                <select id="checkers-mode">
                    <option value="2p">2 Player</option>
                    <option value="easy">Easy Bot</option>
                    <option value="medium" selected>Medium Bot</option>
                    <option value="hard">Hard Bot</option>
                    <option value="impossible">Impossible Bot</option>
                </select>
                <button class="btn-small" onclick="checkersReset()">New Game</button>
            </div>
            <div id="checkers-board" class="board checkers"></div>
            <div id="checkers-status" class="status"></div>
        </div>

        <div id="game-connect4" class="game-inner">
            <div class="game-header"><h2>Connect Four</h2></div>
            <div class="game-options">
                <label>Mode:</label>
                <select id="connect4-mode">
                    <option value="2p">2 Player</option>
                    <option value="easy">Easy Bot</option>
                    <option value="medium" selected>Medium Bot</option>
                    <option value="hard">Hard Bot</option>
                    <option value="impossible">Impossible Bot</option>
                </select>
                <button class="btn-small" onclick="connect4Reset()">New Game</button>
            </div>
            <div id="connect4-board" class="board connect4"></div>
            <div id="connect4-status" class="status"></div>
        </div>

        <div id="game-chess" class="game-inner">
            <div class="game-header"><h2>Chess</h2></div>
            <div class="game-options">
                <label>Mode:</label>
                <select id="chess-mode">
                    <option value="2p">2 Player</option>
                    <option value="easy">Easy Bot</option>
                    <option value="medium" selected>Medium Bot</option>
                    <option value="hard">Hard Bot</option>
                    <option value="impossible">Impossible Bot</option>
                </select>
                <button class="btn-small" onclick="chessReset()">New Game</button>
            </div>
            <div id="chess-board" class="board chess"></div>
            <div id="chess-status" class="status"></div>
        </div>

        <div id="game-tetris" class="game-inner">
            <div class="game-header"><h2>Tetris</h2></div>
            <div style="display: flex; gap: 20px; justify-content: center; align-items: flex-start; flex-wrap: wrap;">
                <div>
                    <canvas id="tetrisCanvas" width="300" height="600" style="border: 2px solid var(--accent); background: #000; border-radius: 4px; display: block;"></canvas>
                    <div style="background: var(--bg-elevated); border: 1px solid var(--border-subtle); border-radius: 4px; padding: 12px; margin-top: 12px; color: var(--text-soft); font-size: 13px; line-height: 1.6;">
                        <div><strong>← →</strong> Move</div>
                        <div><strong>↓</strong> Drop faster</div>
                        <div><strong>↑</strong> Rotate</div>
                        <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--border-subtle);">Swipe to control on mobile</div>
                    </div>
                </div>
                <div style="display: flex; flex-direction: column; gap: 12px; min-width: 140px;">
                    <div style="background: var(--bg-elevated); border: 1px solid var(--border-subtle); border-radius: 4px; padding: 12px; text-align: center;">
                        <div style="color: var(--text-soft); font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 8px;">Score</div>
                        <div style="color: var(--accent); font-size: 28px; font-weight: 700;" id="tetrisScore">0</div>
                    </div>
                    <div style="background: var(--bg-elevated); border: 1px solid var(--border-subtle); border-radius: 4px; padding: 12px; text-align: center;">
                        <div style="color: var(--text-soft); font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 8px;">Level</div>
                        <div style="color: var(--accent); font-size: 24px; font-weight: 700;" id="tetrisLevel">1</div>
                    </div>
                    <div style="background: var(--bg-elevated); border: 1px solid var(--border-subtle); border-radius: 4px; padding: 12px; text-align: center;">
                        <div style="color: var(--text-soft); font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 8px;">Lines</div>
                        <div style="color: var(--accent); font-size: 24px; font-weight: 700;" id="tetrisLines">0</div>
                    </div>
                    <div style="background: var(--bg-elevated); border: 1px solid var(--border-subtle); border-radius: 4px; padding: 12px; text-align: center;">
                        <div style="color: var(--text-soft); font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 8px;">Next</div>
                        <canvas id="tetrisNextCanvas" width="100" height="100" style="background: #000; border: 1px solid var(--border-subtle); border-radius: 4px; display: block; margin: 0 auto;"></canvas>
                    </div>
                    <button class="btn-small" onclick="tetrisReset()" style="margin-top: 4px;">New Game</button>
                </div>
            </div>
        </div>

        <div id="game-codebreaker" class="game-inner">
            <div class="game-header"><h2>Codebreaker</h2></div>
            <div id="codebreaker-difficulty-select" style="display: flex; flex-direction: column; align-items: center; gap: 20px; max-width: 400px; margin: 0 auto;">
                <div style="text-align: center;">
                    <div style="color: var(--text-main); font-size: 16px; margin-bottom: 20px;">Select Difficulty</div>
                </div>
                <div style="display: flex; flex-direction: column; gap: 10px; width: 100%;">
                    <button class="btn-small" onclick="codebreaker_start_game('easy')" style="background: transparent; border: 2px solid var(--accent-soft); color: var(--text-main); font-size: 16px; padding: 15px;">Easy (3 digits)</button>
                    <button class="btn-small" onclick="codebreaker_start_game('normal')" style="background: transparent; border: 2px solid var(--accent-soft); color: var(--text-main); font-size: 16px; padding: 15px;">Normal (4 digits)</button>
                    <button class="btn-small" onclick="codebreaker_start_game('hard')" style="background: transparent; border: 2px solid var(--accent-soft); color: var(--text-main); font-size: 16px; padding: 15px;">Hard (5 digits)</button>
                </div>
            </div>

            <div id="codebreaker-game" style="display: none; flex-direction: column; align-items: center; gap: 20px; max-width: 600px; margin: 0 auto;">
                <div style="text-align: center;">
                    <div style="color: var(--text-soft); font-size: 14px; margin-bottom: 10px;">Difficulty: <span style="color: var(--accent); text-transform: uppercase;" id="codebreaker-difficulty-display">Normal</span></div>
                    <div style="color: var(--accent); font-size: 32px; font-weight: 700; font-family: monospace; letter-spacing: 8px;" id="codebreaker-secret">????</div>
                </div>
                
                <div style="width: 100%;" id="codebreaker-input-group">
                    <!-- Inputs will be generated here -->
                </div>

                <div style="width: 100%; background: var(--bg-elevated); border: 1px solid var(--border-subtle); border-radius: 4px; padding: 15px;">
                    <div style="color: var(--text-soft); font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 12px;">Attempts: <span style="color: var(--accent); font-weight: 700;" id="codebreaker-attempts">5</span> left</div>
                    <div id="codebreaker-history" style="max-height: 250px; overflow-y: auto;">
                        <div style="color: var(--text-soft); font-size: 13px; text-align: center; padding: 20px;">No guesses yet</div>
                    </div>
                </div>

                <div style="display: flex; gap: 10px; width: 100%;">
                    <button class="btn-small" onclick="codebreaker_reveal()" style="flex: 1;">Show Answer</button>
                    <button class="btn-small" onclick="codebreaker_reset()" style="flex: 1;">Change Difficulty</button>
                </div>
            </div>
        </div>

        <div id="game-gridgame" class="game-inner">
            <div class="game-header"><h2>Block Dash</h2></div>
            <div style="display: flex; flex-direction: column; align-items: center; gap: 15px; max-width: 600px; margin: 0 auto;">
                
                <div class="game-options">
                    <label>Difficulty:</label>
                    <select id="gridgame-difficulty" onchange="gridgame_change_difficulty()">
                        <option value="easy">Easy (8 Hazards)</option>
                        <option value="normal" selected>Normal (16 Hazards)</option>
                        <option value="hard">Hard (32 Hazards)</option>
                    </select>
                    <button class="btn-small" onclick="gridgame_reset()">New Game</button>
                </div>

                <div style="display: flex; justify-content: space-around; width: 100%; padding: 0 20px;">
                    <div style="text-align: center;">
                        <div style="color: var(--text-soft); font-size: 11px; text-transform: uppercase;">Score</div>
                        <div style="color: var(--accent); font-size: 24px; font-weight: 700;" id="gridgame-score">0</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="color: var(--text-soft); font-size: 11px; text-transform: uppercase;">Hazards</div>
                        <div style="color: var(--accent); font-size: 24px; font-weight: 700;" id="gridgame-hazards">0/16</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="color: var(--text-soft); font-size: 11px; text-transform: uppercase;">Status</div>
                        <div style="color: var(--accent); font-size: 24px; font-weight: 700;" id="gridgame-status">PLAYING</div>
                    </div>
                </div>

                <div id="gridgame-grid" style="display: grid; grid-template-columns: repeat(8, 1fr); gap: 3px; padding: 15px; background: var(--bg-elevated); border-radius: 4px; border: 1px solid var(--border-subtle);">
                    <!-- Grid will be generated here -->
                </div>

                <div style="color: var(--text-soft); font-size: 12px; text-align: center; line-height: 1.6;">
                    <div><strong>@</strong> = You | <strong>$</strong> = Collect | <strong>#</strong> = Hazard</div>
                    <div style="margin-top: 8px;">Use WASD, Arrow Keys, or Swipe to move</div>
                </div>
            </div>
        </div>

        <div id="game-hackersim" class="game-inner">
            <div class="game-header"><h2>Hacker Simulator</h2></div>
            <div style="display: flex; flex-direction: column; align-items: center; gap: 20px; max-width: 600px; margin: 0 auto;">
                
                <div style="display: flex; justify-content: space-around; width: 100%; padding: 0 20px;">
                    <div style="text-align: center;">
                        <div style="color: var(--text-soft); font-size: 11px; text-transform: uppercase;">Bitcoin</div>
                        <div style="color: var(--accent); font-size: 24px; font-weight: 700; font-family: monospace;" id="hackersim-bitcoin">0.000</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="color: var(--text-soft); font-size: 11px; text-transform: uppercase;">Power</div>
                        <div style="color: var(--accent); font-size: 24px; font-weight: 700;" id="hackersim-power">1</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="color: var(--text-soft); font-size: 11px; text-transform: uppercase;">Hacked</div>
                        <div style="color: var(--accent); font-size: 24px; font-weight: 700;" id="hackersim-hacked">0</div>
                    </div>
                </div>

                <div id="hackersim-main-menu" style="display: flex; flex-direction: column; gap: 10px; width: 100%;">
                    <div style="background: var(--bg-elevated); border: 1px solid var(--border-subtle); border-radius: 4px; padding: 15px; text-align: center; width: fit-content; margin: 0 auto;">
                        <div style="color: var(--text-soft); font-size: 12px; margin-bottom: 10px;">Current Password:</div>
                        <div id="hackersim-password-wrapper">
                            <div id="hackersim-password-display">????</div>
                        </div>
                    </div>

                    <button class="btn-small" onclick="hackersim_enter_password_menu()" style="width: 100%; background: transparent; border: 2px solid var(--accent-soft); color: var(--text-main);">Enter Password</button>
                    <button class="btn-small" onclick="hackersim_start_crack()" style="width: 100%; background: transparent; border: 2px solid var(--accent-soft); color: var(--text-main);">Crack Password</button>
                    <button class="btn-small" onclick="hackersim_collect_bitcoin()" style="width: 100%; background: transparent; border: 2px solid var(--accent-soft); color: var(--text-main);">Collect Bitcoin</button>
                    <button class="btn-small" onclick="hackersim_upgrade_menu()" style="width: 100%; background: transparent; border: 2px solid var(--accent-soft); color: var(--text-main);">Upgrade Power</button>
                </div>

                <div id="hackersim-enter-menu" style="display: none; flex-direction: column; gap: 10px; width: 100%;">
                    <input type="text" id="hackersim-password-input" placeholder="Enter password (uppercase)" style="background: var(--bg-elevated); border: 1px solid var(--border-subtle); color: var(--text-main); text-align: center; font-size: 18px; padding: 12px; border-radius: 4px; font-family: monospace; letter-spacing: 4px; text-transform: uppercase;" />
                    <button class="btn-small" onclick="hackersim_submit_password()" style="width: 100%;">Submit</button>
                    <button class="btn-small" onclick="hackersim_back_menu()" style="width: 100%; background: transparent; border: 2px solid var(--accent-soft); color: var(--text-main);">Back</button>
                </div>

                <div id="hackersim-crack-menu" style="display: none; flex-direction: column; gap: 10px; width: 100%; text-align: center;">
                    <div style="color: var(--text-soft); margin-bottom: 10px;">Cracking password...</div>
                    <div id="hackersim-crack-timer" style="color: var(--accent); font-size: 32px; font-weight: 700;">0.00s</div>
                    <div id="hackersim-crack-status" style="color: var(--text-soft); font-size: 13px; margin-top: 10px;"></div>
                    <button class="btn-small" onclick="hackersim_copy_password()" style="width: 100%; display: none;" id="hackersim-copy-btn">Copy Password</button>
                </div>

                <div id="hackersim-upgrade-menu" style="display: none; flex-direction: column; gap: 10px; width: 100%;">
                    <div style="background: var(--bg-elevated); border: 1px solid var(--border-subtle); border-radius: 4px; padding: 15px; text-align: center;">
                        <div style="color: var(--text-soft); font-size: 12px; margin-bottom: 8px;">Next Upgrade Cost:</div>
                        <div style="color: var(--accent); font-size: 20px; font-weight: 700; font-family: monospace;" id="hackersim-upgrade-cost">0.5 BTC</div>
                        <div style="color: var(--text-soft); font-size: 12px; margin-top: 12px; margin-bottom: 8px;">Your Balance:</div>
                        <div style="color: var(--accent); font-size: 20px; font-weight: 700; font-family: monospace;" id="hackersim-balance-display">0.000 BTC</div>
                    </div>
                    <button class="btn-small" onclick="hackersim_confirm_upgrade()" style="width: 100%;" id="hackersim-upgrade-btn">Upgrade Power</button>
                    <button class="btn-small" onclick="hackersim_back_menu()" style="width: 100%; background: transparent; border: 2px solid var(--accent-soft); color: var(--text-main);">Back</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        function showSection(id) {
            document.getElementById("zweb").style.display = "none";
            document.getElementById("games").style.display = "none";
            document.getElementById("chatbot").style.display = "none";
            document.getElementById(id).style.display = "block";

            if (id === "zweb") {
                document.getElementById("zweb-frame").style.display = "block";
                document.getElementById("hyperzsearch").style.display = "none";
            }
        }

        var searchBtn = document.getElementById("searchBtn");
        var searchPanel = document.getElementById("searchPanel");
        var searchInput = document.getElementById("searchInput");

        searchBtn.onclick = function () {
            var active = searchBtn.className.indexOf("active") === -1;
            if (active) {
                if (searchBtn.className.indexOf("active") === -1) {
                    searchBtn.className += " active";
                }
                if (searchPanel.className.indexOf("active") === -1) {
                    searchPanel.className += " active";
                }
                setTimeout(function () { searchInput.focus(); }, 50);
            } else {
                searchBtn.className = searchBtn.className.replace(" active", "");
                searchPanel.className = searchPanel.className.replace(" active", "");
            }
        };

        searchInput.onkeydown = function (e) {
            e = e || window.event;
            if (e.key === "Enter" || e.keyCode === 13) {
                runGlobalSearch(searchInput.value.replace(/^\s+|\s+$/g, ""));
            }
        };

        function runGlobalSearch(q) {
            if (!q) return;
            var lower = q.toLowerCase();

            searchBtn.className = searchBtn.className.replace(" active", "");
            searchPanel.className = searchPanel.className.replace(" active", "");

            if (lower.indexOf("tic") !== -1 || lower.indexOf("toe") !== -1 || lower.indexOf("ttt") !== -1) {
                showSection("games");
                openGame("ttt");
                return;
            }
            if (lower.indexOf("rev") !== -1 || lower.indexOf("reversi") !== -1 || lower.indexOf("othello") !== -1) {
                showSection("games");
                openGame("rev");
                return;
            }
            if (lower.indexOf("pong") !== -1) {
                showSection("games");
                openGame("pong");
                return;
            }
            if (lower.indexOf("snake") !== -1) {
                showSection("games");
                openGame("snake");
                return;
            }
            if (lower.indexOf("mine") !== -1 || lower.indexOf("minesweeper") !== -1) {
                showSection("games");
                openGame("minesweeper");
                return;
            }
            if (lower.indexOf("2048") !== -1) {
                showSection("games");
                openGame("2048");
                return;
            }
            if (lower.indexOf("flappy") !== -1 || lower.indexOf("bird") !== -1) {
                showSection("games");
                openGame("flappybird");
                return;
            }
            if (lower.indexOf("checker") !== -1) {
                showSection("games");
                openGame("checkers");
                return;
            }
            if (lower.indexOf("connect") !== -1 || lower.indexOf("four") !== -1) {
                showSection("games");
                openGame("connect4");
                return;
            }
            if (lower.indexOf("chess") !== -1) {
                showSection("games");
                openGame("chess");
                return;
            }

            showSection("chatbot");
            addChatMessage(q, "user");
            handleChat(q);
        }

        var tabs = [];
        var currentTab = null;

        function createTab(url) {
            if (!url) url = "New Tab";
            var id = new Date().getTime();
            var tab = { id: id, url: url };
            tabs.push(tab);

            var tabEl = document.createElement("div");
            tabEl.className = "tab";
            tabEl.setAttribute("data-id", id);

            var title = document.createElement("span");
            title.innerHTML = url;

            var close = document.createElement("span");
            close.className = "close-btn";
            close.innerHTML = "&times;";
            close.onclick = (function (tid) {
                return function (e) {
                    if (e && e.stopPropagation) e.stopPropagation();
                    closeTab(tid);
                };
            })(id);

            tabEl.appendChild(title);
            tabEl.appendChild(close);

            tabEl.onclick = (function (tid) {
                return function () {
                    switchTab(tid);
                };
            })(id);

            var tabsBar = document.getElementById("tabs");
            tabsBar.insertBefore(tabEl, tabsBar.querySelector(".new-tab-btn"));

            switchTab(id);
        }

        function switchTab(id) {
            var i;
            currentTab = null;
            for (i = 0; i < tabs.length; i++) {
                if (tabs[i].id === id) {
                    currentTab = tabs[i];
                    break;
                }
            }
            var tabEls = document.getElementsByClassName("tab");
            for (i = 0; i < tabEls.length; i++) {
                var el = tabEls[i];
                var tid = parseInt(el.getAttribute("data-id"), 10);
                if (tid === id) {
                    if (el.className.indexOf("active") === -1) {
                        el.className += " active";
                    }
                } else {
                    el.className = el.className.replace(" active", "");
                }
            }

            if (!currentTab) return;

            document.getElementById("hyperzsearch").style.display = "none";
            document.getElementById("zweb-frame").style.display = "block";

            if (currentTab.url === "New Tab") {
                document.getElementById("zweb-frame").src = "about:blank";
                document.getElementById("zweb-url").value = "";
            } else {
                loadTab(currentTab.url);
            }
        }

        function closeTab(id) {
            var i;
            var index = -1;
            for (i = 0; i < tabs.length; i++) {
                if (tabs[i].id === id) {
                    index = i;
                    break;
                }
            }
            if (index === -1) return;

            tabs.splice(index, 1);

            var tabEls = document.getElementsByClassName("tab");
            for (i = tabEls.length - 1; i >= 0; i--) {
                if (parseInt(tabEls[i].getAttribute("data-id"), 10) === id) {
                    tabEls[i].parentNode.removeChild(tabEls[i]);
                    break;
                }
            }

            if (currentTab && currentTab.id === id) {
                if (tabs.length > 0) {
                    var newIndex = index - 1;
                    if (newIndex < 0) newIndex = 0;
                    switchTab(tabs[newIndex].id);
                } else {
                    createTab();
                }
            }
        }

        function loadTab(url) {
            var frame = document.getElementById("zweb-frame");
            var input = document.getElementById("zweb-url");

            if (url.indexOf("http://") !== 0 && url.indexOf("https://") !== 0) {
                url = "https://" + url;
            }

            frame.src = url;
            input.value = url;
            currentTab.url = url;

            var tabEls = document.getElementsByClassName("tab");
            var i;
            for (i = 0; i < tabEls.length; i++) {
                if (parseInt(tabEls[i].getAttribute("data-id"), 10) === currentTab.id) {
                    var span = tabEls[i].getElementsByTagName("span")[0];
                    var short = url.replace(/^https?:\/\//, "");
                    if (short.length > 18) short = short.substring(0, 15) + "...";
                    span.innerHTML = short;
                    break;
                }
            }
        }

        function zwebNavigate() {
            var q = document.getElementById("zweb-url").value.replace(/^\s+|\s+$/g, "");
            if (!q) return;

            var isURL = (
                q.indexOf("http://") === 0 ||
                q.indexOf("https://") === 0 ||
                q.indexOf(".") !== -1
            );

            if (isURL) {
                if (!currentTab) createTab(q);
                loadTab(q);
                return;
            }

            runHyperZSearch(q);
        }

        document.getElementById("zweb-url").onkeydown = function (e) {
            e = e || window.event;
            if (e.key === "Enter" || e.keyCode === 13) {
                zwebNavigate();
            }
        };

        createTab();
        showSection("zweb");

        function openGame(gameId) {
            document.getElementById("game-overlay").style.display = "block";
            document.getElementById("game-ttt").style.display = "none";
            document.getElementById("game-rev").style.display = "none";
            document.getElementById("game-pong").style.display = "none";
            document.getElementById("game-snake").style.display = "none";
            document.getElementById("game-minesweeper").style.display = "none";
            document.getElementById("game-2048").style.display = "none";
            document.getElementById("game-flappybird").style.display = "none";
            document.getElementById("game-checkers").style.display = "none";
            document.getElementById("game-connect4").style.display = "none";
            document.getElementById("game-chess").style.display = "none";
            document.getElementById("game-tetris").style.display = "none";
            document.getElementById("game-codebreaker").style.display = "none";
            document.getElementById("game-gridgame").style.display = "none";
            document.getElementById("game-hackersim").style.display = "none";

            if (gameId === "ttt") {
                document.getElementById("game-ttt").style.display = "block";
                tttReset();
            } else if (gameId === "rev") {
                document.getElementById("game-rev").style.display = "block";
                revReset();
            } else if (gameId === "pong") {
                document.getElementById("game-pong").style.display = "block";
                pongReset();
            } else if (gameId === "snake") {
                document.getElementById("game-snake").style.display = "block";
                snakeReset();
            } else if (gameId === "minesweeper") {
                document.getElementById("game-minesweeper").style.display = "block";
                minesweaperReset();
            } else if (gameId === "2048") {
                document.getElementById("game-2048").style.display = "block";
                game2048Reset();
            } else if (gameId === "flappybird") {
                document.getElementById("game-flappybird").style.display = "block";
                flappybirdReset();
            } else if (gameId === "checkers") {
                document.getElementById("game-checkers").style.display = "block";
                checkersReset();
            } else if (gameId === "connect4") {
                document.getElementById("game-connect4").style.display = "block";
                connect4Reset();
            } else if (gameId === "chess") {
                document.getElementById("game-chess").style.display = "block";
                chessReset();
            } else if (gameId === "tetris") {
                document.getElementById("game-tetris").style.display = "block";
                tetrisInit();
            } else if (gameId === "codebreaker") {
                document.getElementById("game-codebreaker").style.display = "block";
                codebreaker_reset();
            } else if (gameId === "gridgame") {
                document.getElementById("game-gridgame").style.display = "block";
                gridgame_reset();
            } else if (gameId === "hackersim") {
                document.getElementById("game-hackersim").style.display = "block";
                hackersim_reset();
            }
        }

        function closeGame() {
            document.getElementById("game-overlay").style.display = "none";
            pongStop();
            snakeRunning = false;
            if (snakeTimer) clearInterval(snakeTimer);
            minesweaperRunning = false;
        }

        var tttBoardEl = document.getElementById("ttt-board");
        var tttStatusEl = document.getElementById("ttt-status");
        var tttModeEl = document.getElementById("ttt-mode");
        var tttBoard, tttCurrent, tttGameOver;

        function tttInitBoard() {
            var i;
            tttBoard = [];
            for (i = 0; i < 9; i++) tttBoard.push(null);
            tttCurrent = "X";
            tttGameOver = false;
            tttBoardEl.innerHTML = "";
            for (i = 0; i < 9; i++) {
                (function (idx) {
                    var cell = document.createElement("div");
                    cell.className = "cell";
                    cell.onclick = function () { tttClick(idx); };
                    tttBoardEl.appendChild(cell);
                })(i);
            }
            tttStatusEl.innerHTML = "X's turn";
        }

        function tttCheckWinner(b) {
            var lines = [
                [0,1,2],[3,4,5],[6,7,8],
                [0,3,6],[1,4,7],[2,5,8],
                [0,4,8],[2,4,6]
            ];
            var i, a, c, d;
            for (i = 0; i < lines.length; i++) {
                a = lines[i][0];
                c = lines[i][1];
                d = lines[i][2];
                if (b[a] && b[a] === b[c] && b[a] === b[d]) return b[a];
            }
            for (i = 0; i < 9; i++) {
                if (!b[i]) return null;
            }
            return "draw";
        }

        function tttClick(i) {
            if (tttGameOver || tttBoard[i]) return;
            var mode = tttModeEl.value;
            var cells = tttBoardEl.children;

            tttBoard[i] = tttCurrent;
            cells[i].innerHTML = tttCurrent;

            var res = tttCheckWinner(tttBoard);
            if (res) {
                tttGameOver = true;
                tttStatusEl.innerHTML = (res === "draw" ? "Draw!" : (res + " wins!"));
                return;
            }

            if (mode === "2p") {
                tttCurrent = (tttCurrent === "X" ? "O" : "X");
                tttStatusEl.innerHTML = tttCurrent + "'s turn";
            } else {
                tttStatusEl.innerHTML = "Bot thinking...";
                setTimeout(function () { tttBotMove(mode); }, 200);
            }
        }

        function tttFindWinningMove(player) {
            var i, res;
            for (i = 0; i < 9; i++) {
                if (!tttBoard[i]) {
                    tttBoard[i] = player;
                    res = tttCheckWinner(tttBoard);
                    tttBoard[i] = null;
                    if (res === player) return i;
                }
            }
            return null;
        }

        function tttBestMoveRandomish() {
            var center = 4;
            if (!tttBoard[center]) return center;
            var corners = [0,2,6,8];
            var avail = [];
            var i;
            for (i = 0; i < corners.length; i++) {
                if (!tttBoard[corners[i]]) avail.push(corners[i]);
            }
            if (avail.length) return avail[Math.floor(Math.random() * avail.length)];
            var sides = [1,3,5,7];
            avail = [];
            for (i = 0; i < sides.length; i++) {
                if (!tttBoard[sides[i]]) avail.push(sides[i]);
            }
            if (avail.length) return avail[Math.floor(Math.random() * avail.length)];
            return null;
        }

        function tttBestMoveMinimax() {
            function minimax(board, isMax) {
                var res = tttCheckWinner(board);
                var i, best, val;
                if (res === "O") return 10;
                if (res === "X") return -10;
                if (res === "draw") return 0;

                if (isMax) {
                    best = -9999;
                    for (i = 0; i < 9; i++) {
                        if (!board[i]) {
                            board[i] = "O";
                            val = minimax(board, false);
                            board[i] = null;
                            if (val > best) best = val;
                        }
                    }
                    return best;
                } else {
                    best = 9999;
                    for (i = 0; i < 9; i++) {
                        if (!board[i]) {
                            board[i] = "X";
                            val = minimax(board, true);
                            board[i] = null;
                            if (val < best) best = val;
                        }
                    }
                    return best;
                }
            }

            var bestVal = -9999;
            var bestMove = null;
            var i, val;
            for (i = 0; i < 9; i++) {
                if (!tttBoard[i]) {
                    tttBoard[i] = "O";
                    val = minimax(tttBoard, false);
                    tttBoard[i] = null;
                    if (val > bestVal) {
                        bestVal = val;
                        bestMove = i;
                    }
                }
            }
            return bestMove;
        }

        function tttBotMove(mode) {
            if (tttGameOver) return;
            var cells = tttBoardEl.children;
            var empties = [];
            var i;
            for (i = 0; i < 9; i++) {
                if (!tttBoard[i]) empties.push(i);
            }
            if (!empties.length) return;

            var move;
            if (mode === "easy") {
                move = empties[Math.floor(Math.random() * empties.length)];
            } else if (mode === "medium") {
                move = tttFindWinningMove("O");
                if (move === null) move = tttFindWinningMove("X");
                if (move === null) move = empties[Math.floor(Math.random() * empties.length)];
            } else if (mode === "hard") {
                move = tttFindWinningMove("O");
                if (move === null) move = tttFindWinningMove("X");
                if (move === null) move = tttBestMoveRandomish();
            } else {
                move = tttBestMoveMinimax();
            }

            tttBoard[move] = "O";
            cells[move].innerHTML = "O";

            var res = tttCheckWinner(tttBoard);
            if (res) {
                tttGameOver = true;
                tttStatusEl.innerHTML = (res === "draw" ? "Draw!" : (res + " wins!"));
                return;
            }
            tttStatusEl.innerHTML = "Your turn";
        }

        function tttReset() {
            tttInitBoard();
        }

        tttInitBoard();

        var revBoardEl = document.getElementById("rev-board");
        var revStatusEl = document.getElementById("rev-status");
        var revModeEl = document.getElementById("rev-mode");
        var revBoard, revCurrent, revGameOver;
        var revLastMove = null;
        var revLastFlipped = [];
        var revAnimating = false;

        function revInitBoard() {
            var r, c;
            revBoard = [];
            for (r = 0; r < 8; r++) {
                revBoard[r] = [];
                for (c = 0; c < 8; c++) revBoard[r][c] = null;
            }
            revCurrent = "B";
            revGameOver = false;
            revBoard[3][3] = "W";
            revBoard[3][4] = "B";
            revBoard[4][3] = "B";
            revBoard[4][4] = "W";
            revLastMove = null;
            revLastFlipped = [];
            revRender();
            revStatusEl.innerHTML = "Black (●) to move";
        }

        function revRender() {
            revBoardEl.innerHTML = "";
            var r, c, cell, v;
            for (r = 0; r < 8; r++) {
                for (c = 0; c < 8; c++) {
                    (function (rr, cc) {
                        cell = document.createElement("div");
                        cell.className = "cell reversi-cell";
                        cell.onclick = function () { revClick(rr, cc); };
                        v = revBoard[rr][cc];
                        if (v === "B") cell.innerHTML = "●";
                        else if (v === "W") cell.innerHTML = "○";
                        revBoardEl.appendChild(cell);
                    })(r, c);
                }
            }

            if (revLastMove) {
                var idx = revLastMove.r * 8 + revLastMove.c;
                if (revBoardEl.children[idx]) {
                    revBoardEl.children[idx].style.background = "#0044aa";
                }
            }

            var i;
            for (i = 0; i < revLastFlipped.length; i++) {
                r = revLastFlipped[i][0];
                c = revLastFlipped[i][1];
                idx = r * 8 + c;
                if (revBoardEl.children[idx]) {
                    revBoardEl.children[idx].style.background = "#006600";
                }
            }
        }

        function revInBounds(r, c) {
            return r >= 0 && r < 8 && c >= 0 && c < 8;
        }

        function revGetFlips(r, c, player, board) {
            if (!board) board = revBoard;
            var opp = (player === "B" ? "W" : "B");
            var flips = [];
            if (board[r][c]) return flips;
            var dr, dc, rr, cc, line;
            for (dr = -1; dr <= 1; dr++) {
                for (dc = -1; dc <= 1; dc++) {
                    if (dr === 0 && dc === 0) continue;
                    rr = r + dr;
                    cc = c + dc;
                    line = [];
                    while (revInBounds(rr, cc) && board[rr][cc] === opp) {
                        line.push([rr, cc]);
                        rr += dr;
                        cc += dc;
                    }
                    if (line.length && revInBounds(rr, cc) && board[rr][cc] === player) {
                        flips = flips.concat(line);
                    }
                }
            }
            return flips;
        }

        function revValidMoves(player, board) {
            if (!board) board = revBoard;
            var moves = [];
            var r, c, flips;
            for (r = 0; r < 8; r++) {
                for (c = 0; c < 8; c++) {
                    flips = revGetFlips(r, c, player, board);
                    if (flips.length) moves.push([r, c]);
                }
            }
            return moves;
        }

        function revApplyMove(r, c, player, board) {
            var flips = revGetFlips(r, c, player, board);
            if (!flips.length) return null;
            var i;
            board[r][c] = player;
            for (i = 0; i < flips.length; i++) {
                board[flips[i][0]][flips[i][1]] = player;
            }
            return flips;
        }

        function revClick(r, c) {
            if (revGameOver || revAnimating) return;
            var mode = revModeEl.value;
            var flips = revGetFlips(r, c, revCurrent);
            if (!flips.length) return;

            revAnimating = true;
            revPlayMoveAnimated(r, c, revCurrent, flips, function () {
                revAnimating = false;
                revNextTurn(mode);
            });
        }

        function revPlayMoveAnimated(r, c, player, flips, done) {
            revBoard[r][c] = player;
            revLastMove = { r: r, c: c, player: player };
            revLastFlipped = [];
            revRender();

            var i = 0;
            function step() {
                if (i < flips.length) {
                    var fr = flips[i][0];
                    var fc = flips[i][1];
                    revBoard[fr][fc] = player;
                    revLastFlipped = flips.slice(0, i + 1);
                    i++;
                    revRender();
                    setTimeout(step, 40);
                } else {
                    revLastFlipped = flips;
                    revRender();
                    setTimeout(done, 400);
                }
            }
            step();
        }

        function revNextTurn(mode) {
            if (revGameOver) return;

            var currentMoves = revValidMoves(revCurrent);
            var otherPlayer = (revCurrent === "B" ? "W" : "B");
            var otherMoves = revValidMoves(otherPlayer);

            var r, c, b, w, i;

            if (currentMoves.length === 0 && otherMoves.length === 0) {
                revGameOver = true;
                b = 0; w = 0;
                for (r = 0; r < 8; r++) {
                    for (c = 0; c < 8; c++) {
                        if (revBoard[r][c] === "B") b++;
                        if (revBoard[r][c] === "W") w++;
                    }
                }
                if (b > w) revStatusEl.innerHTML = "Black (●) wins " + b + " - " + w;
                else if (w > b) revStatusEl.innerHTML = "White (○) wins " + w + " - " + b;
                else revStatusEl.innerHTML = "Draw " + b + " - " + w;
                revRender();
                return;
            }

            if (currentMoves.length === 0 && otherMoves.length > 0) {
                revCurrent = otherPlayer;
                revStatusEl.innerHTML = (revCurrent === "B" ? "Black (●)" : "White (○)") + " to move (other player had no moves)";
                revRender();
                if (mode !== "2p" && revCurrent === "W") {
                    setTimeout(function () { revBotMove(mode); }, 500);
                }
                return;
            }

            revCurrent = otherPlayer;
            revStatusEl.innerHTML = (revCurrent === "B" ? "Black (●)" : "White (○)") + " to move";

            if (revLastMove) {
                revStatusEl.innerHTML =
                    (revLastMove.player === "B" ? "Black (●)" : "White (○)") +
                    " played <b>" + (revLastMove.r + 1) + "," + (revLastMove.c + 1) + "</b><br>" +
                    "Flipped: " + revLastFlipped.length;
            }

            revRender();

            if (mode !== "2p" && revCurrent === "W") {
                setTimeout(function () { revBotMove(mode); }, 500);
            }
        }

        function revBotMove(mode) {
            if (revGameOver || revAnimating) return;
            var move = revBotChooseMove(mode, "W");
            if (!move) {
                revNextTurn(mode);
                return;
            }
            var r = move[0];
            var c = move[1];
            var flips = revGetFlips(r, c, "W");
            if (!flips.length) {
                revNextTurn(mode);
                return;
            }
            revAnimating = true;
            revPlayMoveAnimated(r, c, "W", flips, function () {
                revAnimating = false;
                revNextTurn(mode);
            });
        }

        function revBotChooseMove(mode, player) {
            var moves = revValidMoves(player);
            if (!moves.length) return null;

            var i, r, c, flips, best, bestScore, boardCopy, opp, oppMoves;

            if (mode === "easy") {
                return moves[Math.floor(Math.random() * moves.length)];
            }

            if (mode === "medium") {
                best = null;
                bestScore = -1;
                for (i = 0; i < moves.length; i++) {
                    r = moves[i][0];
                    c = moves[i][1];
                    flips = revGetFlips(r, c, player);
                    if (flips.length > bestScore) {
                        bestScore = flips.length;
                        best = [r, c];
                    }
                }
                return best;
            }

            if (mode === "hard") {
                best = null;
                bestScore = 9999;
                for (i = 0; i < moves.length; i++) {
                    r = moves[i][0];
                    c = moves[i][1];
                    boardCopy = revCopyBoard(revBoard);
                    revApplyMove(r, c, player, boardCopy);
                    opp = (player === "B" ? "W" : "B");
                    oppMoves = revValidMoves(opp, boardCopy).length;
                    if (oppMoves < bestScore) {
                        bestScore = oppMoves;
                        best = [r, c];
                    }
                }
                return best;
            }

            var depth = 3;
            opp = (player === "B" ? "W" : "B");

            function scoreBoard(board) {
                var b = 0, w = 0, r2, c2;
                for (r2 = 0; r2 < 8; r2++) {
                    for (c2 = 0; c2 < 8; c2++) {
                        if (board[r2][c2] === "B") b++;
                        if (board[r2][c2] === "W") w++;
                    }
                }
                return (player === "B" ? (b - w) : (w - b));
            }

            function minimax(board, curPlayer, d, alpha, beta) {
                if (d === 0) return scoreBoard(board);
                var curMoves = revValidMoves(curPlayer, board);
                if (!curMoves.length) return scoreBoard(board);

                var bestVal, i2, r3, c3, copy, val;
                if (curPlayer === player) {
                    bestVal = -9999;
                    for (i2 = 0; i2 < curMoves.length; i2++) {
                        r3 = curMoves[i2][0];
                        c3 = curMoves[i2][1];
                        copy = revCopyBoard(board);
                        revApplyMove(r3, c3, curPlayer, copy);
                        val = minimax(copy, opp, d - 1, alpha, beta);
                        if (val > bestVal) bestVal = val;
                        if (val > alpha) alpha = val;
                        if (beta <= alpha) break;
                    }
                    return bestVal;
                } else {
                    bestVal = 9999;
                    for (i2 = 0; i2 < curMoves.length; i2++) {
                        r3 = curMoves[i2][0];
                        c3 = curMoves[i2][1];
                        copy = revCopyBoard(board);
                        revApplyMove(r3, c3, curPlayer, copy);
                        val = minimax(copy, player, d - 1, alpha, beta);
                        if (val < bestVal) bestVal = val;
                        if (val < beta) beta = val;
                        if (beta <= alpha) break;
                    }
                    return bestVal;
                }
            }

            var bestMove = null;
            var bestVal = -9999;
            var val2;
            for (i = 0; i < moves.length; i++) {
                r = moves[i][0];
                c = moves[i][1];
                boardCopy = revCopyBoard(revBoard);
                revApplyMove(r, c, player, boardCopy);
                val2 = minimax(boardCopy, opp, depth - 1, -9999, 9999);
                if (val2 > bestVal) {
                    bestVal = val2;
                    bestMove = [r, c];
                }
            }
            if (!bestMove) bestMove = moves[0];
            return bestMove;
        }

        function revCopyBoard(board) {
            var r, c, copy = [];
            for (r = 0; r < 8; r++) {
                copy[r] = [];
                for (c = 0; c < 8; c++) copy[r][c] = board[r][c];
            }
            return copy;
        }

        function revReset() {
            revInitBoard();
        }

        revInitBoard();

        var pongCanvas = document.getElementById("pong-canvas");
        var pongCtx = pongCanvas.getContext("2d");
        var pongStatusEl = document.getElementById("pong-status");
        var pongModeEl = document.getElementById("pong-mode");

        var pongBall, pongLeft, pongRight;
        var pongKeys = {};
        var pongRunning = false;
        var pongTimer = null;
        var leftScore = 0;
        var rightScore = 0;

        function pongInit() {
            pongBall = {
                x: pongCanvas.width / 2,
                y: pongCanvas.height / 2,
                vx: 3,
                vy: 2.5,
                r: 6
            };
            pongLeft = { x: 20, y: pongCanvas.height / 2 - 40, w: 10, h: 80 };
            pongRight = { x: pongCanvas.width - 30, y: pongCanvas.height / 2 - 40, w: 10, h: 80 };
            leftScore = 0;
            rightScore = 0;
            pongStatusEl.innerHTML = leftScore + " | " + rightScore + " (first to 10)";
        }

        function pongReset() {
            pongInit();
            pongRunning = true;
            if (pongTimer) clearInterval(pongTimer);
            pongTimer = setInterval(pongLoop, 1000 / 120);
        }

        function pongStop() {
            pongRunning = false;
            if (pongTimer) {
                clearInterval(pongTimer);
                pongTimer = null;
            }
        }

        function resetBall(direction) {
            if (!direction) direction = 1;
            pongBall.x = pongCanvas.width / 2;
            pongBall.y = pongCanvas.height / 2;
            pongBall.vx = 3 * direction;
            pongBall.vy = (Math.random() > 0.5 ? 1 : -1) * 2.5;
        }

        window.addEventListener("keydown", function (e) {
            pongKeys[e.key] = true;
        });
        window.addEventListener("keyup", function (e) {
            pongKeys[e.key] = false;
        });

        function pongUpdate() {
            if (!pongRunning) return;

            var mode = pongModeEl.value;

            if (pongKeys["w"]) pongLeft.y -= 4;
            if (pongKeys["s"]) pongLeft.y += 4;

            if (mode === "2p") {
                if (pongKeys["ArrowUp"]) pongRight.y -= 4;
                if (pongKeys["ArrowDown"]) pongRight.y += 4;
            } else {
                var speed = (mode === "easy" ? 2 : (mode === "medium" ? 3 : 4));
                if (pongBall.y < pongRight.y + pongRight.h / 2) pongRight.y -= speed;
                else pongRight.y += speed;
            }

            if (pongLeft.y < 0) pongLeft.y = 0;
            if (pongLeft.y + pongLeft.h > pongCanvas.height) pongLeft.y = pongCanvas.height - pongLeft.h;
            if (pongRight.y < 0) pongRight.y = 0;
            if (pongRight.y + pongRight.h > pongCanvas.height) pongRight.y = pongCanvas.height - pongRight.h;

            pongBall.x += pongBall.vx;
            pongBall.y += pongBall.vy;

            if (pongBall.y - pongBall.r < 0 || pongBall.y + pongBall.r > pongCanvas.height) {
                pongBall.vy *= -1;
            }

            if (pongBall.x - pongBall.r < pongLeft.x + pongLeft.w &&
                pongBall.y > pongLeft.y && pongBall.y < pongLeft.y + pongLeft.h) {
                pongBall.vx = Math.abs(pongBall.vx);
            }

            if (pongBall.x + pongBall.r > pongRight.x &&
                pongBall.y > pongRight.y && pongBall.y < pongRight.y + pongRight.h) {
                pongBall.vx = -Math.abs(pongBall.vx);
            }

            if (pongBall.x < 0) {
                rightScore++;
                if (rightScore >= 10) {
                    pongStatusEl.innerHTML = leftScore + " | " + rightScore + " — Right wins!";
                    pongStop();
                } else {
                    resetBall(1);
                    pongStatusEl.innerHTML = leftScore + " | " + rightScore + " (first to 10)";
                }
            } else if (pongBall.x > pongCanvas.width) {
                leftScore++;
                if (leftScore >= 10) {
                    pongStatusEl.innerHTML = leftScore + " | " + rightScore + " — Left wins!";
                    pongStop();
                } else {
                    resetBall(-1);
                    pongStatusEl.innerHTML = leftScore + " | " + rightScore + " (first to 10)";
                }
            }
        }

        function pongDraw() {
            pongCtx.clearRect(0, 0, pongCanvas.width, pongCanvas.height);
            pongCtx.fillStyle = "#00b4ff";
            pongCtx.fillRect(pongLeft.x, pongLeft.y, pongLeft.w, pongLeft.h);
            pongCtx.fillRect(pongRight.x, pongRight.y, pongRight.w, pongRight.h);
            pongCtx.beginPath();
            pongCtx.arc(pongBall.x, pongBall.y, pongBall.r, 0, Math.PI * 2);
            pongCtx.fill();

            pongCtx.fillStyle = "#00b4ff";
            pongCtx.font = "16px Segoe UI";
            pongCtx.fillText(leftScore + " | " + rightScore, pongCanvas.width / 2 - 30, 20);
        }

        function pongLoop() {
            pongUpdate();
            pongDraw();
        }

        pongInit();

        var chatLog = document.getElementById("chat-log");
        var chatInput = document.getElementById("chat-input");

        chatInput.onkeydown = function (e) {
            e = e || window.event;
            if (e.key === "Enter" || e.keyCode === 13) chatSend();
        };

        function addChatMessage(text, who) {
            var wrapper = document.createElement("div");
            var label = document.createElement("div");
            var bubble = document.createElement("div");

            wrapper.style.display = "flex";
            wrapper.style.flexDirection = "column";
            wrapper.style.marginBottom = "6px";

            label.className = "chat-label";
            bubble.className = "chat-msg " + who;

            if (who === "user") {
                wrapper.style.alignItems = "flex-end";
                label.innerHTML = "You";
            } else {
                wrapper.style.alignItems = "flex-start";
                label.innerHTML = "HyperZAI";
            }

            bubble.innerHTML = text;

            wrapper.appendChild(label);
            wrapper.appendChild(bubble);
            chatLog.appendChild(wrapper);

            // Autoscroll to bottom
            chatLog.scrollTop = chatLog.scrollHeight;
        }

        function chatSend() {
            var q = chatInput.value.replace(/^\s+|\s+$/g, "");
            if (!q) return;
            chatInput.value = "";
            addChatMessage(q, "user");
            handleChat(q);
        }

        function handleChat(q) {
            if (looksLikeMath(q)) {
                try {
                    var res = evalMathExpression(q);
                    addChatMessage(String(res), "bot");
                } catch (e) {
                    addChatMessage("Math error: " + e.message, "bot");
                }
            } else {
                fetchWikipedia(q);
            }
        }

        function looksLikeMath(q) {
            if (/[Σσ]/.test(q)) return true;
            if (/factorial|fib|fibonacci/i.test(q)) return true;
            if (/[0-9]/.test(q) && /[+\-*/^!]/.test(q)) return true;
            if (/sqrt|cos|sin|tan|log|ln/i.test(q)) return true;
            return false;
        }

        function evalMathExpression(expr) {
            expr = expr.replace(/\s+/g, "");

            expr = expr.replace(/Σ\(([^,]+),([^,]+),([^,]+)\)/gi,
                function (_, from, to, body) { return "sigma(" + from + "," + to + ",(" + body + "))"; });

            expr = expr.replace(/Σ_?([a-zA-Z])=([^^]+)\^([^()]+)\(([^)]+)\)/g,
                function (_, v, from, to, body) { return "sigma(" + from + "," + to + ",(" + body + "))"; });

            expr = expr.replace(/fib\(([^)]+)\)/gi, "fib($1)");
            expr = expr.replace(/fibonacci\(([^)]+)\)/gi, "fib($1)");

            expr = expr.replace(/([0-9]+)!/g, "fact($1)");

            var hasDecimal = /[0-9]*\.[0-9]+/.test(expr);
            var hasNonIntOps = /sqrt|cos|sin|tan|log|ln/i.test(expr);

            function fact(n) {
                n = BigInt(n);
                if (n < 0n) throw new Error("factorial of negative");
                var r = 1n;
                var i;
                for (i = 2n; i <= n; i++) r *= i;
                return r;
            }

            function fib(n) {
                n = BigInt(n);
                if (n < 0n) throw new Error("fib of negative");
                var a = 0n, b = 1n, i;
                for (i = 0n; i < n; i++) {
                    var tmp = a;
                    a = b;
                    b = tmp + b;
                }
                return a;
            }

            function sigma(from, to, bodyFnVar) {
                var f = BigInt(from);
                var t = BigInt(to);
                var i, body, replaced;
                if (hasDecimal || hasNonIntOps) {
                    var sum = 0;
                    for (i = Number(f); i <= Number(t); i++) {
                        body = bodyFnVar.toString();
                        replaced = body.replace(/([a-zA-Z])/g, String(i));
                        sum += Number(Function("return " + replaced)());
                    }
                    return sum;
                } else {
                    var sumBig = 0n;
                    for (i = f; i <= t; i++) {
                        body = bodyFnVar.toString();
                        replaced = body.replace(/([a-zA-Z])/g, i.toString());
                        var val = BigInt(Function("return " + replaced)());
                        sumBig += val;
                    }
                    return sumBig;
                }
            }

            if (!hasDecimal && !hasNonIntOps && !/[eE]/.test(expr)) {
                var safe = expr.replace(/\^/g, "**").replace(/([0-9]+)/g, "$1n");
                var fn = Function("fact", "fib", "sigma", "return " + safe);
                return fn(fact, fib, sigma);
            } else {
                var safe2 = expr
                    .replace(/\^/g, "**")
                    .replace(/ln\(/gi, "Math.log(")
                    .replace(/log\(/gi, "Math.log10(")
                    .replace(/sqrt\(/gi, "Math.sqrt(")
                    .replace(/cos\(/gi, "Math.cos(")
                    .replace(/sin\(/gi, "Math.sin(")
                    .replace(/tan\(/gi, "Math.tan(");
                var fn2 = Function("fact", "fib", "sigma", "return " + safe2);
                return fn2(fact, fib, sigma);
            }
        }

        function fetchWikipedia(q) {
            var title = encodeURIComponent(q.replace(/^what\s+is\s+/i, "").replace(/^\s+|\s+$/g, ""));
            var url = "https://en.wikipedia.org/api/rest_v1/page/summary/" + title;

            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, true);
            xhr.onreadystatechange = function () {
                if (xhr.readyState === 4) {
                    if (xhr.status >= 200 && xhr.status < 300) {
                        try {
                            var data = JSON.parse(xhr.responseText);
                            if (data.extract) {
                                addChatMessage(data.extract, "bot");
                            } else {
                                addChatMessage("No summary available for that topic.", "bot");
                            }
                        } catch (e) {
                            addChatMessage("Wikipedia parse error: " + e.message, "bot");
                        }
                    } else {
                        addChatMessage("Wikipedia error: " + xhr.status, "bot");
                    }
                }
            };
            xhr.send(null);
        }

        function runHyperZSearch(query) {
            showSection("zweb");
            document.getElementById("zweb-frame").style.display = "none";
            document.getElementById("hyperzsearch").style.display = "block";

            var resultsBox = document.getElementById("hyperzsearch-results");
            resultsBox.innerHTML = "<p style='color:#a9b3d9;'>Searching Wikipedia for: <b>" + query + "</b>...</p>";

            var url = "https://en.wikipedia.org/w/api.php?action=query&list=search&srsearch=" +
                      encodeURIComponent(query) +
                      "&utf8=&format=json&origin=*";

            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, true);

            xhr.onreadystatechange = function () {
                if (xhr.readyState === 4) {
                    if (xhr.status >= 200 && xhr.status < 300) {
                        try {
                            var data = JSON.parse(xhr.responseText);
                            var items = data.query && data.query.search ? data.query.search : [];

                            if (!items.length) {
                                resultsBox.innerHTML = "<p>No results found.</p>";
                                return;
                            }

                            var html = "";
                            for (var i = 0; i < items.length; i++) {
                                var title = items[i].title;
                                var snippet = items[i].snippet.replace(/<\/?[^>]+(>|$)/g, "");
                                var pageURL = "https://en.wikipedia.org/wiki/" + encodeURIComponent(title);

                                html +=
                                    "<div style='margin-bottom:20px; padding:12px; border:1px solid #1a2238; border-radius:12px; background:#050816;'>" +
                                        "<div style='font-size:18px; color:#00e0ff; cursor:pointer;' onclick='openZWebTab(\"" + pageURL + "\")'>" +
                                            title +
                                        "</div>" +
                                        "<div style='color:#a9b3d9; margin:6px 0;'>" +
                                            snippet +
                                        "</div>" +
                                        "<div style='color:#00b4ff; font-size:13px; cursor:pointer;' onclick='openZWebTab(\"" + pageURL + "\")'>" +
                                            pageURL +
                                        "</div>" +
                                    "</div>";
                            }

                            resultsBox.innerHTML = html;

                        } catch (e) {
                            resultsBox.innerHTML = "<p>Error parsing results.</p>";
                        }
                    } else {
                        resultsBox.innerHTML = "<p>Search error: " + xhr.status + "</p>";
                    }
                }
            };

            xhr.send(null);
        }

        function openZWebTab(url) {
            createTab(url);
            loadTab(url);
            document.getElementById("hyperzsearch").style.display = "none";
            document.getElementById("zweb-frame").style.display = "block";
        }

        // SNAKE GAME
        var snakeCanvas = document.getElementById("snake-canvas");
        var snakeCtx = snakeCanvas.getContext("2d");
        var snakeStatus = document.getElementById("snake-status");
        var snakeDifficultyEl = document.getElementById("snake-difficulty");

        var snake, snakeDir, snakeFood, snakeTimer, snakeRunning;
        var snakeSpeed = 100;

        function snakeReset() {
            snake = [{x:10, y:10}];
            snakeDir = {x:1, y:0};
            snakeFood = spawnFood();
            snakeRunning = true;

            // Set speed based on difficulty
            var difficulty = snakeDifficultyEl.value;
            if (difficulty === "easy") {
                snakeSpeed = 150; // Slower
            } else if (difficulty === "medium") {
                snakeSpeed = 100; // Normal
            } else if (difficulty === "hard") {
                snakeSpeed = 77; // 1.3x faster (100 / 1.3 ≈ 77)
            }

            if (snakeTimer) clearInterval(snakeTimer);
            snakeTimer = setInterval(snakeLoop, snakeSpeed);

            snakeStatus.innerHTML = "Use arrow keys to move";
        }

        function spawnFood() {
            return {
                x: Math.floor(Math.random()*20),
                y: Math.floor(Math.random()*20)
            };
        }

        window.addEventListener("keydown", function(e){
            if (!snakeRunning) return;
            var key = e.key.toLowerCase();
            if ((key === "arrowup" || key === "w") && snakeDir.y !== 1) snakeDir = {x:0, y:-1};
            if ((key === "arrowdown" || key === "s") && snakeDir.y !== -1) snakeDir = {x:0, y:1};
            if ((key === "arrowleft" || key === "a") && snakeDir.x !== 1) snakeDir = {x:-1, y:0};
            if ((key === "arrowright" || key === "d") && snakeDir.x !== -1) snakeDir = {x:1, y:0};
        });

        function snakeLoop() {
            if (!snakeRunning) return;

            var head = {x: snake[0].x + snakeDir.x, y: snake[0].y + snakeDir.y};

            if (head.x < 0 || head.x >= 20 || head.y < 0 || head.y >= 20) {
                snakeGameOver();
                return;
            }

            for (var i=0; i<snake.length; i++) {
                if (snake[i].x === head.x && snake[i].y === head.y) {
                    snakeGameOver();
                    return;
                }
            }

            snake.unshift(head);

            if (head.x === snakeFood.x && head.y === snakeFood.y) {
                snakeFood = spawnFood();
            } else {
                snake.pop();
            }

            snakeDraw();
        }

        function snakeDraw() {
            snakeCtx.clearRect(0,0,400,400);

            snakeCtx.fillStyle = "#00e0ff";
            for (var i=0; i<snake.length; i++) {
                snakeCtx.fillRect(snake[i].x*20, snake[i].y*20, 20, 20);
            }

            snakeCtx.fillStyle = "#ff4b81";
            snakeCtx.fillRect(snakeFood.x*20, snakeFood.y*20, 20, 20);
        }

        function snakeGameOver() {
            snakeRunning = false;
            clearInterval(snakeTimer);
            snakeStatus.innerHTML = "Game Over — press Reset";
        }

        // Touch gesture support for Snake
        var snakeTouchStartX = 0;
        var snakeTouchStartY = 0;

        document.addEventListener("touchstart", function (e) {
            snakeTouchStartX = e.touches[0].clientX;
            snakeTouchStartY = e.touches[0].clientY;
        });

        document.addEventListener("touchend", function (e) {
            if (document.getElementById("game-snake").style.display !== "block" || !snakeRunning) return;

            var snakeTouchEndX = e.changedTouches[0].clientX;
            var snakeTouchEndY = e.changedTouches[0].clientY;

            var snakeDeltaX = snakeTouchEndX - snakeTouchStartX;
            var snakeDeltaY = snakeTouchEndY - snakeTouchStartY;

            var snakeAbsDeltaX = Math.abs(snakeDeltaX);
            var snakeAbsDeltaY = Math.abs(snakeDeltaY);

            if (snakeAbsDeltaX > snakeAbsDeltaY && snakeAbsDeltaX > 40) {
                if (snakeDeltaX > 0 && snakeDir.x !== -1) snakeDir = {x:1, y:0};
                else if (snakeDeltaX < 0 && snakeDir.x !== 1) snakeDir = {x:-1, y:0};
            } else if (snakeAbsDeltaY > snakeAbsDeltaX && snakeAbsDeltaY > 40) {
                if (snakeDeltaY > 0 && snakeDir.y !== -1) snakeDir = {x:0, y:1};
                else if (snakeDeltaY < 0 && snakeDir.y !== 1) snakeDir = {x:0, y:-1};
            }
        });

        // MINESWEEPER GAME
        var minesweeperBoard = null;
        var minesweeperBoardEl = document.getElementById("minesweeper-board");
        var minesweeperStatusEl = document.getElementById("minesweeper-status");
        var minesweeperDifficultyEl = document.getElementById("minesweeper-difficulty");
        var minesweaperRunning = false;
        var minesweeperRevealed = 0;
        var minesweeperFlagged = 0;
        var minesweeperGameOver = false;

        function minesweeperGetConfig(difficulty) {
            if (difficulty === "easy") return { rows: 10, cols: 10, mines: 10 };
            if (difficulty === "medium") return { rows: 10, cols: 10, mines: 30 };
            if (difficulty === "hard") return { rows: 10, cols: 10, mines: 50 };
            return { rows: 10, cols: 10, mines: 30 };
        }

        function minesweeperInit() {
            var config = minesweeperGetConfig(minesweeperDifficultyEl.value);
            var rows = config.rows;
            var cols = config.cols;
            var mineCount = config.mines;

            minesweeperBoard = [];
            var i, j;
            for (i = 0; i < rows; i++) {
                minesweeperBoard[i] = [];
                for (j = 0; j < cols; j++) {
                    minesweeperBoard[i][j] = {
                        mine: false,
                        revealed: false,
                        flagged: false,
                        adjMines: 0
                    };
                }
            }

            var placed = 0;
            while (placed < mineCount) {
                var r = Math.floor(Math.random() * rows);
                var c = Math.floor(Math.random() * cols);
                if (!minesweeperBoard[r][c].mine) {
                    minesweeperBoard[r][c].mine = true;
                    placed++;
                }
            }

            for (i = 0; i < rows; i++) {
                for (j = 0; j < cols; j++) {
                    if (!minesweeperBoard[i][j].mine) {
                        var count = 0;
                        var dr, dc;
                        for (dr = -1; dr <= 1; dr++) {
                            for (dc = -1; dc <= 1; dc++) {
                                var nr = i + dr;
                                var nc = j + dc;
                                if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && minesweeperBoard[nr][nc].mine) {
                                    count++;
                                }
                            }
                        }
                        minesweeperBoard[i][j].adjMines = count;
                    }
                }
            }

            minesweeperRevealed = 0;
            minesweeperFlagged = 0;
            minesweeperGameOver = false;
            minesweaperRunning = true;
            minesweeperRender();
            minesweeperStatusEl.innerHTML = "Click to reveal, right-click to flag";
        }

        function minesweeperRender() {
            minesweeperBoardEl.innerHTML = "";
            var i, j, cell, data;
            for (i = 0; i < minesweeperBoard.length; i++) {
                for (j = 0; j < minesweeperBoard[i].length; j++) {
                    (function (r, c) {
                        cell = document.createElement("div");
                        cell.className = "cell minesweeper-cell";
                        data = minesweeperBoard[r][c];

                        if (data.revealed) {
                            cell.className += " revealed";
                            if (data.mine) {
                                cell.innerHTML = "💣";
                                cell.className += " mine";
                            } else if (data.adjMines > 0) {
                                cell.innerHTML = String(data.adjMines);
                                cell.style.color = ["", "#00e0ff", "#00ff88", "#ffaa00", "#ff6600", "#ff4444", "#ff0000", "#990000", "#660000"][data.adjMines];
                            }
                        } else if (data.flagged) {
                            cell.innerHTML = "🚩";
                            cell.className += " flagged";
                        } else {
                            cell.style.background = "#0a1020";
                        }

                        cell.onclick = function () { minesweeperClick(r, c, "left"); };
                        cell.oncontextmenu = function (e) {
                            e.preventDefault();
                            minesweeperClick(r, c, "right");
                        };

                        minesweeperBoardEl.appendChild(cell);
                    })(i, j);
                }
            }
        }

        function minesweeperClick(r, c, button) {
            if (minesweeperGameOver || !minesweaperRunning) return;
            var data = minesweeperBoard[r][c];

            if (button === "right") {
                if (!data.revealed) {
                    data.flagged = !data.flagged;
                    if (data.flagged) minesweeperFlagged++;
                    else minesweeperFlagged--;
                }
                minesweeperRender();
                return;
            }

            if (data.revealed || data.flagged) return;

            if (data.mine) {
                minesweeperGameOver = true;
                minesweaperRunning = false;
                minesweeperRevealAll();
                minesweeperStatusEl.innerHTML = "Game Over — hit a mine!";
                return;
            }

            minesweeperReveal(r, c);

            if (minesweeperCheckWin()) {
                minesweeperGameOver = true;
                minesweaperRunning = false;
                minesweeperStatusEl.innerHTML = "You won!";
            }

            minesweeperRender();
        }

        function minesweeperReveal(r, c) {
            var data = minesweeperBoard[r][c];
            if (data.revealed) return;
            data.revealed = true;
            data.flagged = false;
            minesweeperRevealed++;

            if (data.adjMines === 0) {
                var i, j;
                for (i = r - 1; i <= r + 1; i++) {
                    for (j = c - 1; j <= c + 1; j++) {
                        if (i >= 0 && i < minesweeperBoard.length && j >= 0 && j < minesweeperBoard[0].length) {
                            if (!minesweeperBoard[i][j].revealed && !minesweeperBoard[i][j].mine) {
                                minesweeperReveal(i, j);
                            }
                        }
                    }
                }
            }
        }

        function minesweeperRevealAll() {
            var i, j;
            for (i = 0; i < minesweeperBoard.length; i++) {
                for (j = 0; j < minesweeperBoard[i].length; j++) {
                    minesweeperBoard[i][j].revealed = true;
                }
            }
        }

        function minesweeperCheckWin() {
            var i, j;
            for (i = 0; i < minesweeperBoard.length; i++) {
                for (j = 0; j < minesweeperBoard[i].length; j++) {
                    var data = minesweeperBoard[i][j];
                    if (!data.mine && !data.revealed) return false;
                }
            }
            return true;
        }

        function minesweaperReset() {
            minesweeperInit();
        }

        minesweeperInit();

        // 2048 GAME
        var game2048Board = null;
        var game2048Score = 0;
        var game2048GameOver = false;
        var game2048Won = false;
        var game2048MergedTiles = {};

        function game2048Init() {
            game2048Board = [];
            var i, j;
            for (i = 0; i < 4; i++) {
                game2048Board[i] = [];
                for (j = 0; j < 4; j++) {
                    game2048Board[i][j] = 0;
                }
            }
            game2048Score = 0;
            game2048GameOver = false;
            game2048Won = false;
            game2048MergedTiles = {};
            game2048AddTile();
            game2048AddTile();
            game2048Render();
            document.getElementById("2048-status").innerHTML = "Use arrow keys to move tiles";
        }

        function game2048AddTile() {
            var empty = [];
            var i, j;
            for (i = 0; i < 4; i++) {
                for (j = 0; j < 4; j++) {
                    if (game2048Board[i][j] === 0) {
                        empty.push([i, j]);
                    }
                }
            }
            if (empty.length === 0) return;
            var pos = empty[Math.floor(Math.random() * empty.length)];
            var val = Math.random() < 0.9 ? 2 : 4;
            game2048Board[pos[0]][pos[1]] = val;
        }

        function game2048Render() {
            var board = document.getElementById("2048-board");
            board.innerHTML = "";
            var i, j, cell, val, key;
            for (i = 0; i < 4; i++) {
                for (j = 0; j < 4; j++) {
                    cell = document.createElement("div");
                    cell.className = "tile-2048";
                    val = game2048Board[i][j];
                    key = i + "," + j;
                    if (val === 0) {
                        cell.className += " empty";
                    } else {
                        cell.setAttribute("data-value", val);
                        cell.innerHTML = val;
                        // Add merge animation if this tile was just merged
                        if (game2048MergedTiles[key]) {
                            cell.className += " merge";
                        } else {
                            cell.className += " slide";
                        }
                    }
                    board.appendChild(cell);
                }
            }
            document.getElementById("2048-score").innerHTML = "Score: " + game2048Score;
            // Clear merged tiles after render
            game2048MergedTiles = {};
        }

        function game2048Move(direction) {
            if (game2048GameOver) return;
            var moved = false;
            if (direction === "left") {
                moved = game2048MoveLeft();
            } else if (direction === "right") {
                moved = game2048MoveRight();
            } else if (direction === "up") {
                moved = game2048MoveUp();
            } else if (direction === "down") {
                moved = game2048MoveDown();
            }
            if (moved) {
                game2048AddTile();
                game2048Render();
                if (game2048CheckGameOver()) {
                    game2048GameOver = true;
                    document.getElementById("2048-status").innerHTML = "Game Over! No more moves.";
                }
                if (!game2048Won && game2048CheckWin()) {
                    game2048Won = true;
                    document.getElementById("2048-status").innerHTML = "You reached 2048! Keep going for more.";
                }
            }
        }

        function game2048MoveLeft() {
            var moved = false;
            var i, j, k;
            for (i = 0; i < 4; i++) {
                for (j = 0; j < 3; j++) {
                    for (k = j; k < 3; k++) {
                        if (game2048Board[i][k] === 0 && game2048Board[i][k + 1] !== 0) {
                            game2048Board[i][k] = game2048Board[i][k + 1];
                            game2048Board[i][k + 1] = 0;
                            moved = true;
                        }
                    }
                }
                for (j = 0; j < 3; j++) {
                    if (game2048Board[i][j] !== 0 && game2048Board[i][j] === game2048Board[i][j + 1]) {
                        game2048Board[i][j] *= 2;
                        game2048Score += game2048Board[i][j];
                        game2048MergedTiles[i + "," + j] = true;
                        game2048Board[i][j + 1] = 0;
                        moved = true;
                    }
                }
                for (j = 0; j < 3; j++) {
                    for (k = j; k < 3; k++) {
                        if (game2048Board[i][k] === 0 && game2048Board[i][k + 1] !== 0) {
                            game2048Board[i][k] = game2048Board[i][k + 1];
                            game2048Board[i][k + 1] = 0;
                            moved = true;
                        }
                    }
                }
            }
            return moved;
        }

        function game2048MoveRight() {
            var moved = false;
            var i, j, k;
            for (i = 0; i < 4; i++) {
                for (j = 3; j > 0; j--) {
                    for (k = j; k > 0; k--) {
                        if (game2048Board[i][k] === 0 && game2048Board[i][k - 1] !== 0) {
                            game2048Board[i][k] = game2048Board[i][k - 1];
                            game2048Board[i][k - 1] = 0;
                            moved = true;
                        }
                    }
                }
                for (j = 3; j > 0; j--) {
                    if (game2048Board[i][j] !== 0 && game2048Board[i][j] === game2048Board[i][j - 1]) {
                        game2048Board[i][j] *= 2;
                        game2048Score += game2048Board[i][j];
                        game2048MergedTiles[i + "," + j] = true;
                        game2048Board[i][j - 1] = 0;
                        moved = true;
                    }
                }
                for (j = 3; j > 0; j--) {
                    for (k = j; k > 0; k--) {
                        if (game2048Board[i][k] === 0 && game2048Board[i][k - 1] !== 0) {
                            game2048Board[i][k] = game2048Board[i][k - 1];
                            game2048Board[i][k - 1] = 0;
                            moved = true;
                        }
                    }
                }
            }
            return moved;
        }

        function game2048MoveUp() {
            var moved = false;
            var i, j, k;
            for (j = 0; j < 4; j++) {
                for (i = 0; i < 3; i++) {
                    for (k = i; k < 3; k++) {
                        if (game2048Board[k][j] === 0 && game2048Board[k + 1][j] !== 0) {
                            game2048Board[k][j] = game2048Board[k + 1][j];
                            game2048Board[k + 1][j] = 0;
                            moved = true;
                        }
                    }
                }
                for (i = 0; i < 3; i++) {
                    if (game2048Board[i][j] !== 0 && game2048Board[i][j] === game2048Board[i + 1][j]) {
                        game2048Board[i][j] *= 2;
                        game2048Score += game2048Board[i][j];
                        game2048MergedTiles[i + "," + j] = true;
                        game2048Board[i + 1][j] = 0;
                        moved = true;
                    }
                }
                for (i = 0; i < 3; i++) {
                    for (k = i; k < 3; k++) {
                        if (game2048Board[k][j] === 0 && game2048Board[k + 1][j] !== 0) {
                            game2048Board[k][j] = game2048Board[k + 1][j];
                            game2048Board[k + 1][j] = 0;
                            moved = true;
                        }
                    }
                }
            }
            return moved;
        }

        function game2048MoveDown() {
            var moved = false;
            var i, j, k;
            for (j = 0; j < 4; j++) {
                for (i = 3; i > 0; i--) {
                    for (k = i; k > 0; k--) {
                        if (game2048Board[k][j] === 0 && game2048Board[k - 1][j] !== 0) {
                            game2048Board[k][j] = game2048Board[k - 1][j];
                            game2048Board[k - 1][j] = 0;
                            moved = true;
                        }
                    }
                }
                for (i = 3; i > 0; i--) {
                    if (game2048Board[i][j] !== 0 && game2048Board[i][j] === game2048Board[i - 1][j]) {
                        game2048Board[i][j] *= 2;
                        game2048Score += game2048Board[i][j];
                        game2048MergedTiles[i + "," + j] = true;
                        game2048Board[i - 1][j] = 0;
                        moved = true;
                    }
                }
                for (i = 3; i > 0; i--) {
                    for (k = i; k > 0; k--) {
                        if (game2048Board[k][j] === 0 && game2048Board[k - 1][j] !== 0) {
                            game2048Board[k][j] = game2048Board[k - 1][j];
                            game2048Board[k - 1][j] = 0;
                            moved = true;
                        }
                    }
                }
            }
            return moved;
        }

        function game2048CheckGameOver() {
            var i, j;
            for (i = 0; i < 4; i++) {
                for (j = 0; j < 4; j++) {
                    if (game2048Board[i][j] === 0) return false;
                }
            }
            for (i = 0; i < 4; i++) {
                for (j = 0; j < 3; j++) {
                    if (game2048Board[i][j] === game2048Board[i][j + 1]) return false;
                }
            }
            for (i = 0; i < 3; i++) {
                for (j = 0; j < 4; j++) {
                    if (game2048Board[i][j] === game2048Board[i + 1][j]) return false;
                }
            }
            return true;
        }

        function game2048CheckWin() {
            var i, j;
            for (i = 0; i < 4; i++) {
                for (j = 0; j < 4; j++) {
                    if (game2048Board[i][j] === 2048) return true;
                }
            }
            return false;
        }

        function game2048Reset() {
            game2048Init();
        }

        window.addEventListener("keydown", function (e) {
            if (document.getElementById("game-2048").style.display === "block") {
                if (e.key === "ArrowLeft") {
                    e.preventDefault();
                    game2048Move("left");
                } else if (e.key === "ArrowRight") {
                    e.preventDefault();
                    game2048Move("right");
                } else if (e.key === "ArrowUp") {
                    e.preventDefault();
                    game2048Move("up");
                } else if (e.key === "ArrowDown") {
                    e.preventDefault();
                    game2048Move("down");
                }
            }
        });

        // Touch gesture support for 2048
        var touchStartX = 0;
        var touchStartY = 0;
        var touchMinDistance = 50;

        document.addEventListener("touchstart", function (e) {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });

        document.addEventListener("touchend", function (e) {
            if (document.getElementById("game-2048").style.display !== "block") return;

            var touchEndX = e.changedTouches[0].clientX;
            var touchEndY = e.changedTouches[0].clientY;

            var deltaX = touchEndX - touchStartX;
            var deltaY = touchEndY - touchStartY;

            var absDeltaX = Math.abs(deltaX);
            var absDeltaY = Math.abs(deltaY);

            if (absDeltaX > absDeltaY && absDeltaX > touchMinDistance) {
                e.preventDefault();
                if (deltaX > 0) {
                    game2048Move("right");
                } else {
                    game2048Move("left");
                }
            } else if (absDeltaY > absDeltaX && absDeltaY > touchMinDistance) {
                e.preventDefault();
                if (deltaY > 0) {
                    game2048Move("down");
                } else {
                    game2048Move("up");
                }
            }
        });

        // FLAPPY BIRD GAME
        var flappybirdCanvas = document.getElementById("flappybird-canvas");
        var flappybirdCtx = flappybirdCanvas.getContext("2d");
        var flappybirdScore = 0;
        var flappybirdGameRunning = false;
        var flappybirdGameOver = false;
        var flappybirdStarted = false;

        var bird = {
            x: 60,
            y: flappybirdCanvas.height / 2,
            width: 30,
            height: 30,
            velocityY: 0,
            gravity: 0.6,
            jumpPower: -8
        };

        var pipes = [];
        var pipeWidth = 60;
        var pipeGap = 120;
        var pipeHitboxWidth = 54;
        var pipeFrequency = 100;
        var pipeCounter = 0;
        var flappybirdTimer = null;
        
        // Base difficulty values
        var basePipeSpeed = 4;
        var baseGravity = 0.6;
        var basePipeFrequency = 100;
        var currentPipeSpeed = 4;
        var currentGravity = 0.6;
        var currentPipeFrequency = 100;

        function flappybirdInit() {
            bird.y = flappybirdCanvas.height / 2;
            bird.velocityY = 0;
            pipes = [];
            flappybirdScore = 0;
            flappybirdGameOver = false;
            flappybirdStarted = false;
            pipeCounter = 0;
            currentPipeSpeed = basePipeSpeed;
            currentGravity = baseGravity;
            currentPipeFrequency = basePipeFrequency;
            bird.gravity = currentGravity;
            pipeFrequency = currentPipeFrequency;
            document.getElementById("flappybird-score").innerHTML = "Score: 0";
            document.getElementById("flappybird-status").innerHTML = "Click canvas or press SPACE to flap";
        }
        
        function flappybirdUpdateDifficulty() {
            var levelUp = Math.floor(flappybirdScore / 5);
            if (levelUp > 0) {
                currentPipeSpeed = basePipeSpeed * (1 + levelUp * 0.05);
                currentGravity = baseGravity * (1 + levelUp * 0.02);
                bird.gravity = currentGravity;
                pipeFrequency = Math.max(60, basePipeFrequency - levelUp * 5);
            }
        }

        function flappybirdReset() {
            flappybirdInit();
            flappybirdGameRunning = true;
            if (flappybirdTimer) clearInterval(flappybirdTimer);
            flappybirdTimer = setInterval(flappybirdLoop, 1000 / 60);
        }

        function flappybirdStop() {
            flappybirdGameRunning = false;
            if (flappybirdTimer) {
                clearInterval(flappybirdTimer);
                flappybirdTimer = null;
            }
        }

        function flappybirdFlap() {
            if (flappybirdGameRunning && !flappybirdGameOver) {
                flappybirdStarted = true;
                bird.velocityY = bird.jumpPower;
            }
        }

        function flappybirdUpdate() {
            if (!flappybirdGameRunning) return;

            // Apply gravity only after first flap
            if (flappybirdStarted) {
                bird.velocityY += bird.gravity;
            }
            bird.y += bird.velocityY;

            // Check bounds
            if (bird.y <= 0 || bird.y + bird.height >= flappybirdCanvas.height) {
                flappybirdGameOver = true;
                document.getElementById("flappybird-status").innerHTML = "Game Over! Score: " + flappybirdScore;
                flappybirdStop();
                return;
            }

            // Generate pipes only after game has started
            if (flappybirdStarted) {
                pipeCounter++;
                if (pipeCounter > pipeFrequency) {
                    var gapStart = Math.random() * (flappybirdCanvas.height - pipeGap - 60) + 30;
                    pipes.push({
                        x: flappybirdCanvas.width,
                        topHeight: gapStart,
                        scored: false
                    });
                    pipeCounter = 0;
                }
                // Update difficulty every frame based on score
                flappybirdUpdateDifficulty();
            }

            // Update pipes
            for (var i = pipes.length - 1; i >= 0; i--) {
                pipes[i].x -= currentPipeSpeed;

                // Check collision (with 90% hitbox)
                var hitboxOffsetX = (pipeWidth - pipeHitboxWidth) / 2;
                if (bird.x < pipes[i].x + pipeHitboxWidth + hitboxOffsetX &&
                    bird.x + bird.width > pipes[i].x + hitboxOffsetX &&
                    (bird.y < pipes[i].topHeight ||
                     bird.y + bird.height > pipes[i].topHeight + pipeGap)) {
                    flappybirdGameOver = true;
                    document.getElementById("flappybird-status").innerHTML = "Game Over! Score: " + flappybirdScore;
                    flappybirdStop();
                    return;
                }

                // Score point
                if (!pipes[i].scored && pipes[i].x + pipeWidth < bird.x) {
                    pipes[i].scored = true;
                    flappybirdScore++;
                    document.getElementById("flappybird-score").innerHTML = "Score: " + flappybirdScore;
                }

                // Remove off-screen pipes
                if (pipes[i].x + pipeWidth < 0) {
                    pipes.splice(i, 1);
                }
            }
        }

        function flappybirdDraw() {
            // Draw sky gradient
            var gradient = flappybirdCtx.createLinearGradient(0, 0, 0, flappybirdCanvas.height);
            gradient.addColorStop(0, "#87ceeb");
            gradient.addColorStop(1, "#e0f6ff");
            flappybirdCtx.fillStyle = gradient;
            flappybirdCtx.fillRect(0, 0, flappybirdCanvas.width, flappybirdCanvas.height);

            // Draw ground
            flappybirdCtx.fillStyle = "#2d5016";
            flappybirdCtx.fillRect(0, flappybirdCanvas.height - 40, flappybirdCanvas.width, 40);

            // Draw bird
            flappybirdCtx.fillStyle = "#ffd700";
            flappybirdCtx.beginPath();
            flappybirdCtx.arc(bird.x + bird.width / 2, bird.y + bird.height / 2, bird.width / 2, 0, Math.PI * 2);
            flappybirdCtx.fill();
            // Bird eye
            flappybirdCtx.fillStyle = "#000";
            flappybirdCtx.beginPath();
            flappybirdCtx.arc(bird.x + bird.width / 2 + 5, bird.y + bird.height / 2 - 3, 3, 0, Math.PI * 2);
            flappybirdCtx.fill();

            // Draw pipes
            flappybirdCtx.fillStyle = "#2d5016";
            for (var i = 0; i < pipes.length; i++) {
                var pipe = pipes[i];
                // Top pipe
                flappybirdCtx.fillRect(pipe.x, 0, pipeWidth, pipe.topHeight);
                // Bottom pipe
                flappybirdCtx.fillRect(pipe.x, pipe.topHeight + pipeGap, pipeWidth, flappybirdCanvas.height - pipe.topHeight - pipeGap);

                // Pipe highlights
                flappybirdCtx.fillStyle = "#3a7c1f";
                flappybirdCtx.fillRect(pipe.x + 2, pipe.topHeight - 20, pipeWidth - 4, 20);
                flappybirdCtx.fillRect(pipe.x + 2, pipe.topHeight + pipeGap, pipeWidth - 4, 20);
                flappybirdCtx.fillStyle = "#2d5016";
            }
        }

        function flappybirdLoop() {
            flappybirdUpdate();
            flappybirdDraw();
        }

        // Input controls
        flappybirdCanvas.addEventListener("click", flappybirdFlap);
        document.addEventListener("keydown", function (e) {
            if (document.getElementById("game-flappybird").style.display === "block") {
                if (e.key === " " || e.key === "Spacebar" || e.key === "w" || e.key === "W" || e.key === "ArrowUp") {
                    e.preventDefault();
                    flappybirdFlap();
                }
            }
        });

        // Touch support for Flappy Bird
        flappybirdCanvas.addEventListener("touchstart", function (e) {
            e.preventDefault();
            flappybirdFlap();
        });

        // CHECKERS GAME
        var checkersBoard = null;
        var checkersModeEl = document.getElementById("checkers-mode");
        var checkersBoardEl = document.getElementById("checkers-board");
        var checkersStatusEl = document.getElementById("checkers-status");
        var checkersCurrentPlayer = "red";
        var checkersGameOver = false;
        var checkersSelectedPiece = null;
        var checkersValidMoves = [];

        function checkersInit() {
            checkersBoard = [];
            var i, j;
            for (i = 0; i < 8; i++) {
                checkersBoard[i] = [];
                for (j = 0; j < 8; j++) {
                    checkersBoard[i][j] = null;
                }
            }

            // Place red pieces (top in code, but appears at bottom visually due to reversed rendering)
            for (i = 0; i < 3; i++) {
                for (j = 0; j < 8; j++) {
                    if ((i + j) % 2 === 1) {
                        checkersBoard[i][j] = { color: "red", isKing: false };
                    }
                }
            }

            // Place black pieces (bottom in code, but appears at top visually due to reversed rendering)
            for (i = 5; i < 8; i++) {
                for (j = 0; j < 8; j++) {
                    if ((i + j) % 2 === 1) {
                        checkersBoard[i][j] = { color: "black", isKing: false };
                    }
                }
            }

            checkersCurrentPlayer = "red";
            checkersGameOver = false;
            checkersSelectedPiece = null;
            checkersValidMoves = [];
            checkersRender();
            checkersStatusEl.innerHTML = "Red to move";
        }

        function checkersRender() {
            checkersBoardEl.innerHTML = "";
            var i, j, squareEl, piece;
            // Reverse the loop so row 7 is at top and row 0 is at bottom (red player at bottom)
            for (i = 7; i >= 0; i--) {
                for (j = 0; j < 8; j++) {
                    squareEl = document.createElement("div");
                    squareEl.className = "checkers-square";
                    squareEl.className += (i + j) % 2 === 0 ? " light" : " dark";

                    // Mark selected square
                    if (checkersSelectedPiece && checkersSelectedPiece[0] === i && checkersSelectedPiece[1] === j) {
                        squareEl.className += " selected";
                    }

                    // Mark valid moves
                    var isValidMove = false;
                    for (var k = 0; k < checkersValidMoves.length; k++) {
                        if (checkersValidMoves[k][0] === i && checkersValidMoves[k][1] === j) {
                            squareEl.className += " highlight";
                            isValidMove = true;
                            break;
                        }
                    }

                    // Add piece
                    piece = checkersBoard[i][j];
                    if (piece) {
                        var pieceEl = document.createElement("div");
                        pieceEl.className = "checkers-piece " + piece.color;
                        if (piece.isKing) pieceEl.className += " king";
                        pieceEl.textContent = piece.isKing ? "K" : "";
                        squareEl.appendChild(pieceEl);
                    }

                    // Add click handler
                    (function (row, col) {
                        squareEl.onclick = function () { checkersClick(row, col); };
                    })(i, j);

                    checkersBoardEl.appendChild(squareEl);
                }
            }
        }

        function checkersClick(row, col) {
            if (checkersGameOver) return;
            var mode = checkersModeEl.value;
            if (mode !== "2p" && checkersCurrentPlayer === "black") return;

            // If clicking on a valid move
            var isValidMove = false;
            for (var i = 0; i < checkersValidMoves.length; i++) {
                if (checkersValidMoves[i][0] === row && checkersValidMoves[i][1] === col) {
                    isValidMove = true;
                    checkersMove(checkersSelectedPiece[0], checkersSelectedPiece[1], row, col);
                    checkersSelectedPiece = null;
                    checkersValidMoves = [];
                    checkersRender();
                    checkersNextTurn(mode);
                    return;
                }
            }

            // If clicking on a piece
            var piece = checkersBoard[row][col];
            if (piece && piece.color === checkersCurrentPlayer) {
                checkersSelectedPiece = [row, col];
                checkersValidMoves = checkersGetValidMoves(row, col);
                checkersRender();
                return;
            }

            checkersSelectedPiece = null;
            checkersValidMoves = [];
            checkersRender();
        }

        function checkersGetValidMoves(row, col) {
            var piece = checkersBoard[row][col];
            if (!piece) return [];
            var moves = [];
            var directions = [[1, 1], [1, -1], [-1, 1], [-1, -1]];

            // Regular moves (diagonal)
            for (var i = 0; i < directions.length; i++) {
                var dr = directions[i][0];
                var dc = directions[i][1];

                if (!piece.isKing) {
                    // Red moves down, Black moves up
                    if (piece.color === "red" && dr !== 1) continue;
                    if (piece.color === "black" && dr !== -1) continue;
                }

                var nr = row + dr;
                var nc = col + dc;

                // Forward one space
                if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8 && !checkersBoard[nr][nc]) {
                    moves.push([nr, nc]);
                }

                // Capture move (jump)
                nr = row + dr * 2;
                nc = col + dc * 2;
                var captureRow = row + dr;
                var captureCol = col + dc;

                // Check bounds for capture row/col before accessing
                if (captureRow >= 0 && captureRow < 8 && captureCol >= 0 && captureCol < 8) {
                    var capturePiece = checkersBoard[captureRow][captureCol];

                    if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8 && 
                        capturePiece && capturePiece.color !== piece.color && !checkersBoard[nr][nc]) {
                        moves.push([nr, nc]);
                    }
                }
            }

            return moves;
        }

        function checkersMove(fromRow, fromCol, toRow, toCol) {
            var piece = checkersBoard[fromRow][fromCol];
            var distance = Math.abs(toRow - fromRow);

            // Handle capture
            if (distance === 2) {
                var captureRow = (fromRow + toRow) / 2;
                var captureCol = (fromCol + toCol) / 2;
                checkersBoard[captureRow][captureCol] = null;
            }

            // Move piece
            checkersBoard[toRow][toCol] = piece;
            checkersBoard[fromRow][fromCol] = null;

            // Promote to king
            if ((piece.color === "red" && toRow === 7) || (piece.color === "black" && toRow === 0)) {
                piece.isKing = true;
            }
        }

        function checkersNextTurn(mode) {
            checkersCurrentPlayer = checkersCurrentPlayer === "red" ? "black" : "red";
            checkersStatusEl.innerHTML = (checkersCurrentPlayer === "red" ? "Red" : "Black") + " to move";

            if (mode !== "2p" && checkersCurrentPlayer === "black") {
                setTimeout(function () { checkersBotMove(mode); }, 500);
            }
        }

        function checkersBotMove(mode) {
            if (checkersGameOver || checkersCurrentPlayer !== "black") return;

            var validMoves = [];
            var i, j, moves;

            // Find all valid moves for black
            for (i = 0; i < 8; i++) {
                for (j = 0; j < 8; j++) {
                    if (checkersBoard[i][j] && checkersBoard[i][j].color === "black") {
                        moves = checkersGetValidMoves(i, j);
                        for (var k = 0; k < moves.length; k++) {
                            validMoves.push({ from: [i, j], to: moves[k] });
                        }
                    }
                }
            }

            if (validMoves.length === 0) {
                checkersGameOver = true;
                checkersStatusEl.innerHTML = "Red wins!";
                return;
            }

            var move;
            if (mode === "easy") {
                move = validMoves[Math.floor(Math.random() * validMoves.length)];
            } else if (mode === "medium") {
                // Prefer capture moves
                var captureMoves = [];
                for (i = 0; i < validMoves.length; i++) {
                    if (Math.abs(validMoves[i].to[0] - validMoves[i].from[0]) === 2) {
                        captureMoves.push(validMoves[i]);
                    }
                }
                move = captureMoves.length > 0 ? captureMoves[Math.floor(Math.random() * captureMoves.length)] : validMoves[Math.floor(Math.random() * validMoves.length)];
            } else {
                // Hard/Impossible: prefer captures with random variation
                var bestScore = -9999;
                for (i = 0; i < validMoves.length; i++) {
                    var score = 0;
                    if (Math.abs(validMoves[i].to[0] - validMoves[i].from[0]) === 2) score += 10;
                    score += Math.random() * 5;
                    if (score > bestScore) {
                        bestScore = score;
                        move = validMoves[i];
                    }
                }
            }

            checkersMove(move.from[0], move.from[1], move.to[0], move.to[1]);
            checkersRender();
            checkersNextTurn(mode);
        }

        function checkersReset() {
            checkersInit();
        }

        checkersInit();

        // CONNECT FOUR GAME
        var connect4Board = null;
        var connect4ModeEl = document.getElementById("connect4-mode");
        var connect4BoardEl = document.getElementById("connect4-board");
        var connect4StatusEl = document.getElementById("connect4-status");
        var connect4CurrentPlayer = "red";
        var connect4GameOver = false;
        var connect4Winner = null;

        function connect4Init() {
            connect4Board = [];
            var i, j;
            for (i = 0; i < 6; i++) {
                connect4Board[i] = [];
                for (j = 0; j < 7; j++) {
                    connect4Board[i][j] = null;
                }
            }

            connect4CurrentPlayer = "red";
            connect4GameOver = false;
            connect4Winner = null;
            connect4Render(-1, -1);
            connect4StatusEl.innerHTML = "Red to move";
        }

        var connect4LastDropped = null;

        function connect4Render(lastDropRow, lastDropCol) {
            try {
                connect4BoardEl.innerHTML = "";
                var i, j, cellEl, piece;
                for (i = 0; i < 6; i++) {
                    for (j = 0; j < 7; j++) {
                        cellEl = document.createElement("div");
                        cellEl.className = "cell connect4-cell";

                        piece = connect4Board[i][j];
                        if (piece) {
                            var pieceEl = document.createElement("div");
                            pieceEl.className = "connect4-piece " + piece;
                            // Add falling animation only to the newly dropped piece
                            if (lastDropRow !== undefined && lastDropCol !== undefined && i === lastDropRow && j === lastDropCol) {
                                pieceEl.className += " falling";
                            }
                            if (connect4Winner && connect4Winner.includes(i + "-" + j)) {
                                pieceEl.className += " winner";
                            }
                            cellEl.appendChild(pieceEl);
                        }

                        (function (col) {
                            cellEl.onclick = function () { connect4DropPiece(col); };
                        })(j);

                        connect4BoardEl.appendChild(cellEl);
                    }
                }
            } catch (err) {
                console.error("Render error:", err);
            }
        }

        function connect4DropPiece(col) {
            if (connect4GameOver) return;
            var mode = connect4ModeEl.value;
            
            // In 2-player, anyone can move
            // In single-player, only red (human) can click, but yellow (bot) can be called programmatically
            if (mode !== "2p" && connect4CurrentPlayer !== "red") {
            }

            // Find lowest empty row in column
            var row = -1;
            for (var i = 5; i >= 0; i--) {
                if (!connect4Board[i][col]) {
                    row = i;
                    break;
                }
            }

            if (row === -1) return; // Column full

            // Place piece
            connect4Board[row][col] = connect4CurrentPlayer;

            // Render with animation for this piece
            connect4Render(row, col);

            // Check for win
            if (connect4CheckWin(row, col, connect4CurrentPlayer)) {
                connect4GameOver = true;
                connect4StatusEl.innerHTML = (connect4CurrentPlayer === "red" ? "Red" : "Yellow") + " wins!";
                return;
            }

            // Check for draw
            var isFull = true;
            for (var j = 0; j < 7; j++) {
                if (!connect4Board[0][j]) {
                    isFull = false;
                    break;
                }
            }
            
            if (isFull) {
                connect4GameOver = true;
                connect4StatusEl.innerHTML = "Draw!";
                return;
            }

            // Switch player
            connect4CurrentPlayer = connect4CurrentPlayer === "red" ? "yellow" : "red";
            connect4StatusEl.innerHTML = (connect4CurrentPlayer === "red" ? "Red" : "Yellow") + " to move";

            // If single-player and it's now yellow's turn, make bot move
            if (mode !== "2p" && connect4CurrentPlayer === "yellow") {
                setTimeout(function () { 
                    connect4BotMove(mode); 
                }, 700);
            }
        }

        function connect4CheckWin(row, col, player) {
            var directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
            var winMoves = [];

            for (var d = 0; d < directions.length; d++) {
                var count = 1;
                var moves = [row + "-" + col];

                // Check positive direction
                var r = row + directions[d][0];
                var c = col + directions[d][1];
                while (r >= 0 && r < 6 && c >= 0 && c < 7 && connect4Board[r][c] === player) {
                    count++;
                    moves.push(r + "-" + c);
                    r += directions[d][0];
                    c += directions[d][1];
                }

                // Check negative direction
                r = row - directions[d][0];
                c = col - directions[d][1];
                while (r >= 0 && r < 6 && c >= 0 && c < 7 && connect4Board[r][c] === player) {
                    count++;
                    moves.push(r + "-" + c);
                    r -= directions[d][0];
                    c -= directions[d][1];
                }

                if (count >= 4) {
                    connect4Winner = moves;
                    return true;
                }
            }

            return false;
        }

        function connect4GetValidMoves() {
            var moves = [];
            for (var j = 0; j < 7; j++) {
                if (!connect4Board[0][j]) {
                    moves.push(j);
                }
            }
            return moves;
        }

        function connect4BotMove(mode) {
            if (connect4GameOver) return;

            var validMoves = [];
            for (var col = 0; col < 7; col++) {
                if (!connect4Board[0][col]) {
                    validMoves.push(col);
                }
            }

            if (validMoves.length === 0) return;

            var move;
            
            if (mode === "easy") {
                move = validMoves[Math.floor(Math.random() * validMoves.length)];
            } else if (mode === "medium" || mode === "hard" || mode === "impossible") {
                // Smart bot: Check for winning moves first, then blocking moves, then strategic
                move = connect4EvaluateBotMove(validMoves, mode);
            }
            
            connect4DropPiece(move);
        }

        function connect4EvaluateBotMove(validMoves, mode) {
            // First priority: Check if yellow can win
            for (var i = 0; i < validMoves.length; i++) {
                var col = validMoves[i];
                var row = -1;
                for (var r = 5; r >= 0; r--) {
                    if (!connect4Board[r][col]) {
                        row = r;
                        break;
                    }
                }
                
                if (row === -1) continue;
                
                connect4Board[row][col] = "yellow";
                if (connect4CheckWinBoard(connect4Board, row, col, "yellow")) {
                    connect4Board[row][col] = null;
                    return col; // Instant win - always take it
                }
                connect4Board[row][col] = null;
            }
            
            // Second priority: Block opponent from winning
            for (var i = 0; i < validMoves.length; i++) {
                var col = validMoves[i];
                var row = -1;
                for (var r = 5; r >= 0; r--) {
                    if (!connect4Board[r][col]) {
                        row = r;
                        break;
                    }
                }
                
                if (row === -1) continue;
                
                connect4Board[row][col] = "red";
                if (connect4CheckWinBoard(connect4Board, row, col, "red")) {
                    connect4Board[row][col] = null;
                    return col; // Must block
                }
                connect4Board[row][col] = null;
            }
            
            // Third priority: Strategic moves
            var bestMove = validMoves[0];
            var bestScore = -999;
            
            for (var i = 0; i < validMoves.length; i++) {
                var col = validMoves[i];
                var row = -1;
                for (var r = 5; r >= 0; r--) {
                    if (!connect4Board[r][col]) {
                        row = r;
                        break;
                    }
                }
                
                if (row === -1) continue;
                
                var score = 0;
                
                // Count pieces in lines (4 directions)
                var directions = [[0,1], [1,0], [1,1], [1,-1]];
                for (var d = 0; d < directions.length; d++) {
                    var count = 1;
                    
                    // Check positive direction
                    for (var dist = 1; dist < 4; dist++) {
                        var nr = row + directions[d][0] * dist;
                        var nc = col + directions[d][1] * dist;
                        if (nr >= 0 && nr < 6 && nc >= 0 && nc < 7) {
                            if (connect4Board[nr][nc] === "yellow") count++;
                            else if (connect4Board[nr][nc] === "red") break;
                            else if (connect4Board[nr][nc] === null) break;
                        } else break;
                    }
                    
                    // Check negative direction
                    for (var dist = 1; dist < 4; dist++) {
                        var nr = row - directions[d][0] * dist;
                        var nc = col - directions[d][1] * dist;
                        if (nr >= 0 && nr < 6 && nc >= 0 && nc < 7) {
                            if (connect4Board[nr][nc] === "yellow") count++;
                            else if (connect4Board[nr][nc] === "red") break;
                            else if (connect4Board[nr][nc] === null) break;
                        } else break;
                    }
                    
                    // Higher score for more pieces in a line
                    if (count === 3) score += 500;
                    else if (count === 2) score += 100;
                }
                
                // Prefer center columns for control
                score += (3 - Math.abs(col - 3)) * 10;
                
                // Add randomness based on difficulty
                if (mode === "medium") {
                    score += Math.random() * 100;
                } else if (mode === "hard") {
                    score += Math.random() * 30;
                }
                // impossible has no randomness - pure strategy
                
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = col;
                }
            }
            
            return bestMove;
        }

        function connect4CheckWinBoard(board, row, col, player) {
            var directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
            for (var d = 0; d < directions.length; d++) {
                var count = 1;
                var r = row + directions[d][0];
                var c = col + directions[d][1];
                while (r >= 0 && r < 6 && c >= 0 && c < 7 && board[r][c] === player) {
                    count++;
                    r += directions[d][0];
                    c += directions[d][1];
                }
                r = row - directions[d][0];
                c = col - directions[d][1];
                while (r >= 0 && r < 6 && c >= 0 && c < 7 && board[r][c] === player) {
                    count++;
                    r -= directions[d][0];
                    c -= directions[d][1];
                }
                if (count >= 4) return true;
            }
            return false;
        }

        function connect4Reset() {
            connect4Init();
        }

        connect4Init();

        // CHESS GAME
        var chessBoard = null;
        var chessModeEl = document.getElementById("chess-mode");
        var chessBoardEl = document.getElementById("chess-board");
        var chessStatusEl = document.getElementById("chess-status");
        var chessCurrentPlayer = "white";
        var chessGameOver = false;
        var chessSelectedSquare = null;
        var chessValidMoves = [];
        var chessPendingPromotion = null;

        function chessInit() {
            chessBoard = [];
            for (var i = 0; i < 8; i++) {
                chessBoard[i] = [];
                for (var j = 0; j < 8; j++) {
                    chessBoard[i][j] = null;
                }
            }

            // Set up white pieces (bottom)
            chessBoard[7][0] = {type: "R", color: "white"};
            chessBoard[7][1] = {type: "N", color: "white"};
            chessBoard[7][2] = {type: "B", color: "white"};
            chessBoard[7][3] = {type: "Q", color: "white"};
            chessBoard[7][4] = {type: "K", color: "white"};
            chessBoard[7][5] = {type: "B", color: "white"};
            chessBoard[7][6] = {type: "N", color: "white"};
            chessBoard[7][7] = {type: "R", color: "white"};
            for (var j = 0; j < 8; j++) {
                chessBoard[6][j] = {type: "P", color: "white"};
            }

            // Set up black pieces (top)
            for (var j = 0; j < 8; j++) {
                chessBoard[1][j] = {type: "P", color: "black"};
            }
            chessBoard[0][0] = {type: "R", color: "black"};
            chessBoard[0][1] = {type: "N", color: "black"};
            chessBoard[0][2] = {type: "B", color: "black"};
            chessBoard[0][3] = {type: "Q", color: "black"};
            chessBoard[0][4] = {type: "K", color: "black"};
            chessBoard[0][5] = {type: "B", color: "black"};
            chessBoard[0][6] = {type: "N", color: "black"};
            chessBoard[0][7] = {type: "R", color: "black"};

            chessCurrentPlayer = "white";
            chessGameOver = false;
            chessSelectedSquare = null;
            chessValidMoves = [];
            chessRender();
            chessStatusEl.innerHTML = "White to move";
        }

        function chessRender() {
            chessBoardEl.innerHTML = "";
            for (var i = 0; i < 8; i++) {
                for (var j = 0; j < 8; j++) {
                    var cell = document.createElement("div");
                    cell.className = "cell chess-cell";
                    cell.className += (i + j) % 2 === 0 ? " light" : " dark";

                    // Mark selected
                    if (chessSelectedSquare && chessSelectedSquare[0] === i && chessSelectedSquare[1] === j) {
                        cell.className += " selected";
                    }

                    // Mark valid moves
                    for (var k = 0; k < chessValidMoves.length; k++) {
                        if (chessValidMoves[k][0] === i && chessValidMoves[k][1] === j) {
                            cell.className += " highlight";
                        }
                    }

                    if (chessBoard[i][j]) {
                        var piece = chessBoard[i][j];
                        var symbols = {"P": "♟", "R": "♜", "N": "♞", "B": "♝", "Q": "♛", "K": "♚"};
                        if (piece.color === "white") {
                            symbols = {"P": "♙", "R": "♖", "N": "♘", "B": "♗", "Q": "♕", "K": "♔"};
                        }
                        cell.textContent = symbols[piece.type];
                    }

                    (function(row, col) {
                        cell.onclick = function() { chessClick(row, col); };
                    })(i, j);

                    chessBoardEl.appendChild(cell);
                }
            }
        }

        function chessClick(row, col) {
            if (chessGameOver) return;
            
            // If promotion pending, this is choosing the promotion piece
            if (chessPendingPromotion) {
                return; // Promotion handled by promotion buttons
            }
            
            var mode = chessModeEl.value;
            if (mode !== "2p" && chessCurrentPlayer === "black") return;

            // Check if clicking valid move
            var isValid = false;
            for (var i = 0; i < chessValidMoves.length; i++) {
                if (chessValidMoves[i][0] === row && chessValidMoves[i][1] === col) {
                    isValid = true;
                    chessCompleteMove(chessSelectedSquare[0], chessSelectedSquare[1], row, col, mode);
                    return;
                }
            }

            // Select piece
            if (chessBoard[row][col] && chessBoard[row][col].color === chessCurrentPlayer) {
                chessSelectedSquare = [row, col];
                chessValidMoves = chessGetValidMoves(row, col);
                chessRender();
            } else {
                chessSelectedSquare = null;
                chessValidMoves = [];
                chessRender();
            }
        }

        function chessCompleteMove(fromRow, fromCol, toRow, toCol, mode) {
            var piece = chessBoard[fromRow][fromCol];
            var capturedPiece = chessBoard[toRow][toCol];
            
            // Check if pawn is promoting
            if (piece.type === "P" && ((piece.color === "white" && toRow === 0) || (piece.color === "black" && toRow === 7))) {
                // Show promotion menu
                chessPendingPromotion = {from: [fromRow, fromCol], to: [toRow, toCol], color: piece.color, mode: mode};
                chessShowPromotionMenu();
                return;
            }
            
            // Normal move
            chessMove(fromRow, fromCol, toRow, toCol);
            chessSelectedSquare = null;
            chessValidMoves = [];
            chessRender();
            
            // Check if King was captured (immediate win)
            if (capturedPiece && capturedPiece.type === "K") {
                chessGameOver = true;
                var winner = piece.color === "white" ? "White" : "Black";
                chessStatusEl.innerHTML = "King captured! " + winner + " wins!";
                return;
            }
            
            chessCurrentPlayer = chessCurrentPlayer === "white" ? "black" : "white";
            
            // Check if opponent has any pieces left
            var opponentColor = chessCurrentPlayer;
            var opponentHasPieces = false;
            for (var i = 0; i < 8; i++) {
                for (var j = 0; j < 8; j++) {
                    if (chessBoard[i][j] && chessBoard[i][j].color === opponentColor) {
                        opponentHasPieces = true;
                        break;
                    }
                }
                if (opponentHasPieces) break;
            }
            
            // If opponent has no pieces, current player wins
            if (!opponentHasPieces) {
                chessGameOver = true;
                var winner = piece.color === "white" ? "White" : "Black";
                chessStatusEl.innerHTML = winner + " wins! All pieces captured!";
                return;
            }
            
            // Check for checkmate
            if (chessIsCheckmate(chessCurrentPlayer)) {
                chessGameOver = true;
                var winner = chessCurrentPlayer === "white" ? "Black" : "White";
                chessStatusEl.innerHTML = "Checkmate! " + winner + " wins!";
                return;
            }
            
            // Check if only kings remain (insufficient material = draw)
            if (chessOnlyKingsRemain()) {
                chessGameOver = true;
                chessStatusEl.innerHTML = "Draw! Only kings remaining (insufficient material)";
                return;
            }
            
            // Check for stalemate (only if opponent has pieces)
            if (opponentHasPieces && chessIsStalemate(chessCurrentPlayer)) {
                chessGameOver = true;
                chessStatusEl.innerHTML = "Stalemate! Draw!";
                return;
            }
            
            // Check for check
            if (chessIsInCheck(chessCurrentPlayer)) {
                chessStatusEl.innerHTML = (chessCurrentPlayer === "white" ? "White" : "Black") + " is in Check!";
            } else {
                chessStatusEl.innerHTML = (chessCurrentPlayer === "white" ? "White" : "Black") + " to move";
            }
            
            if (mode !== "2p" && chessCurrentPlayer === "black") {
                setTimeout(function() { chessBotMove(mode); }, 700);
            }
        }

        function chessShowPromotionMenu() {
            chessStatusEl.innerHTML = "Pawn Promotion - Choose a piece";
            var btnsHtml = '<div style="margin-top:10px; display:flex; gap:8px; justify-content:center;">' +
                '<button class="btn-small" onclick="chessPromote(\'Q\')">Queen</button>' +
                '<button class="btn-small" onclick="chessPromote(\'R\')">Rook</button>' +
                '<button class="btn-small" onclick="chessPromote(\'B\')">Bishop</button>' +
                '<button class="btn-small" onclick="chessPromote(\'N\')">Knight</button>' +
                '</div>';
            chessStatusEl.innerHTML += btnsHtml;
        }

        function chessPromote(pieceType) {
            if (!chessPendingPromotion) return;
            
            var promotion = chessPendingPromotion;
            var capturedPiece = chessBoard[promotion.to[0]][promotion.to[1]];
            chessMove(promotion.from[0], promotion.from[1], promotion.to[0], promotion.to[1]);
            
            // Replace pawn with promoted piece
            chessBoard[promotion.to[0]][promotion.to[1]].type = pieceType;
            
            chessSelectedSquare = null;
            chessValidMoves = [];
            chessRender();
            
            // Check if King was captured
            if (capturedPiece && capturedPiece.type === "K") {
                chessGameOver = true;
                var winner = promotion.color === "white" ? "White" : "Black";
                chessStatusEl.innerHTML = "King captured! " + winner + " wins!";
                chessPendingPromotion = null;
                return;
            }
            
            chessCurrentPlayer = chessCurrentPlayer === "white" ? "black" : "white";
            
            // Check if opponent has any pieces left
            var opponentColor = chessCurrentPlayer;
            var opponentHasPieces = false;
            for (var i = 0; i < 8; i++) {
                for (var j = 0; j < 8; j++) {
                    if (chessBoard[i][j] && chessBoard[i][j].color === opponentColor) {
                        opponentHasPieces = true;
                        break;
                    }
                }
                if (opponentHasPieces) break;
            }
            
            // If opponent has no pieces, current player wins
            if (!opponentHasPieces) {
                chessGameOver = true;
                var winner = promotion.color === "white" ? "White" : "Black";
                chessStatusEl.innerHTML = winner + " wins! All pieces captured!";
                chessPendingPromotion = null;
                return;
            }
            
            // Check for checkmate
            if (chessIsCheckmate(chessCurrentPlayer)) {
                chessGameOver = true;
                var winner = chessCurrentPlayer === "white" ? "Black" : "White";
                chessStatusEl.innerHTML = "Checkmate! " + winner + " wins!";
                chessPendingPromotion = null;
                return;
            }
            
            // Check if only kings remain (insufficient material = draw)
            if (chessOnlyKingsRemain()) {
                chessGameOver = true;
                chessStatusEl.innerHTML = "Draw! Only kings remaining (insufficient material)";
                chessPendingPromotion = null;
                return;
            }
            
            // Check for stalemate (only if opponent has pieces)
            if (opponentHasPieces && chessIsStalemate(chessCurrentPlayer)) {
                chessGameOver = true;
                chessStatusEl.innerHTML = "Stalemate! Draw!";
                chessPendingPromotion = null;
                return;
            }
            
            // Check for check
            if (chessIsInCheck(chessCurrentPlayer)) {
                chessStatusEl.innerHTML = (chessCurrentPlayer === "white" ? "White" : "Black") + " is in Check!";
            } else {
                chessStatusEl.innerHTML = (chessCurrentPlayer === "white" ? "White" : "Black") + " to move";
            }
            
            chessPendingPromotion = null;
            
            if (promotion.mode !== "2p" && chessCurrentPlayer === "black") {
                setTimeout(function() { chessBotMove(promotion.mode); }, 700);
            }
        }

        function chessGetValidMoves(row, col) {
            var piece = chessBoard[row][col];
            if (!piece) return [];
            var moves = [];

            if (piece.type === "P") {
                var dir = piece.color === "white" ? -1 : 1;
                var startRow = piece.color === "white" ? 6 : 1;
                
                // Move forward
                if (chessBoard[row + dir] && chessBoard[row + dir][col] === null) {
                    moves.push([row + dir, col]);
                    if (row === startRow && chessBoard[row + dir*2][col] === null) {
                        moves.push([row + dir*2, col]);
                    }
                }
                
                // Capture diagonally
                if (col > 0 && chessBoard[row + dir][col - 1] && chessBoard[row + dir][col - 1].color !== piece.color) {
                    moves.push([row + dir, col - 1]);
                }
                if (col < 7 && chessBoard[row + dir][col + 1] && chessBoard[row + dir][col + 1].color !== piece.color) {
                    moves.push([row + dir, col + 1]);
                }
            } else if (piece.type === "N") {
                var knightMoves = [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
                for (var i = 0; i < knightMoves.length; i++) {
                    var nr = row + knightMoves[i][0];
                    var nc = col + knightMoves[i][1];
                    if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                        if (!chessBoard[nr][nc] || chessBoard[nr][nc].color !== piece.color) {
                            moves.push([nr, nc]);
                        }
                    }
                }
            } else if (piece.type === "B" || piece.type === "R" || piece.type === "Q") {
                var dirs = [];
                if (piece.type === "R" || piece.type === "Q") {
                    dirs = dirs.concat([[1,0],[-1,0],[0,1],[0,-1]]);
                }
                if (piece.type === "B" || piece.type === "Q") {
                    dirs = dirs.concat([[1,1],[1,-1],[-1,1],[-1,-1]]);
                }
                
                for (var d = 0; d < dirs.length; d++) {
                    for (var dist = 1; dist < 8; dist++) {
                        var nr = row + dirs[d][0] * dist;
                        var nc = col + dirs[d][1] * dist;
                        if (nr < 0 || nr >= 8 || nc < 0 || nc >= 8) break;
                        if (!chessBoard[nr][nc]) {
                            moves.push([nr, nc]);
                        } else {
                            if (chessBoard[nr][nc].color !== piece.color) {
                                moves.push([nr, nc]);
                            }
                            break;
                        }
                    }
                }
            } else if (piece.type === "K") {
                for (var i = -1; i <= 1; i++) {
                    for (var j = -1; j <= 1; j++) {
                        if (i === 0 && j === 0) continue;
                        var nr = row + i;
                        var nc = col + j;
                        if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                            if (!chessBoard[nr][nc] || chessBoard[nr][nc].color !== piece.color) {
                                // Check if this square is under attack by enemy
                                var targetPiece = chessBoard[nr][nc];
                                chessBoard[nr][nc] = piece;
                                chessBoard[row][col] = null;
                                
                                var enemyColor = piece.color === "white" ? "black" : "white";
                                var isUnderAttack = chessIsUnderAttack(nr, nc, enemyColor);
                                
                                // Restore board
                                chessBoard[row][col] = piece;
                                chessBoard[nr][nc] = targetPiece;
                                
                                if (!isUnderAttack) {
                                    moves.push([nr, nc]);
                                }
                            }
                        }
                    }
                }
            }

            // Filter out moves that would leave king in check
            var legalMoves = [];
            for (var m = 0; m < moves.length; m++) {
                var testTargetPiece = chessBoard[moves[m][0]][moves[m][1]];
                chessBoard[moves[m][0]][moves[m][1]] = piece;
                chessBoard[row][col] = null;
                
                var kingInCheck = chessIsInCheck(piece.color);
                
                chessBoard[row][col] = piece;
                chessBoard[moves[m][0]][moves[m][1]] = testTargetPiece;
                
                if (!kingInCheck) {
                    legalMoves.push(moves[m]);
                }
            }
            
            return legalMoves;
        }

        function chessMove(fromRow, fromCol, toRow, toCol) {
            chessBoard[toRow][toCol] = chessBoard[fromRow][fromCol];
            chessBoard[fromRow][fromCol] = null;
        }

        function chessFindKing(color) {
            for (var i = 0; i < 8; i++) {
                for (var j = 0; j < 8; j++) {
                    if (chessBoard[i][j] && chessBoard[i][j].type === "K" && chessBoard[i][j].color === color) {
                        return [i, j];
                    }
                }
            }
            return null;
        }

        function chessIsUnderAttack(row, col, byColor) {
            // Check if square at row,col is under attack by byColor
            for (var i = 0; i < 8; i++) {
                for (var j = 0; j < 8; j++) {
                    if (chessBoard[i][j] && chessBoard[i][j].color === byColor) {
                        var moves = chessGetValidMovesRaw(i, j);
                        for (var k = 0; k < moves.length; k++) {
                            if (moves[k][0] === row && moves[k][1] === col) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        function chessIsInCheck(color) {
            var kingPos = chessFindKing(color);
            if (!kingPos) return false;
            var enemyColor = color === "white" ? "black" : "white";
            return chessIsUnderAttack(kingPos[0], kingPos[1], enemyColor);
        }

        function chessIsCheckmate(color) {
            // Checkmate: King is in check AND has no legal moves to escape
            if (!chessIsInCheck(color)) return false;
            
            // Check if player has any legal moves
            for (var i = 0; i < 8; i++) {
                for (var j = 0; j < 8; j++) {
                    if (chessBoard[i][j] && chessBoard[i][j].color === color) {
                        var moves = chessGetValidMoves(i, j);
                        if (moves.length > 0) {
                            // Test each move to see if it gets out of check
                            for (var m = 0; m < moves.length; m++) {
                                var testPiece = chessBoard[moves[m][0]][moves[m][1]];
                                chessBoard[moves[m][0]][moves[m][1]] = chessBoard[i][j];
                                chessBoard[i][j] = null;
                                
                                var stillInCheck = chessIsInCheck(color);
                                
                                chessBoard[i][j] = chessBoard[moves[m][0]][moves[m][1]];
                                chessBoard[moves[m][0]][moves[m][1]] = testPiece;
                                
                                if (!stillInCheck) {
                                    return false; // Found a legal move that escapes check
                                }
                            }
                        }
                    }
                }
            }
            return true; // No moves escape check = checkmate
        }

        function chessOnlyKingsRemain() {
            // Check if only kings are left on the board
            for (var i = 0; i < 8; i++) {
                for (var j = 0; j < 8; j++) {
                    if (chessBoard[i][j] && chessBoard[i][j].type !== "K") {
                        return false; // Found a non-king piece
                    }
                }
            }
            return true; // Only kings remain
        }

        function chessIsStalemate(color) {
            // Stalemate: King is NOT in check BUT has no legal moves AND opponent has pieces
            if (chessIsInCheck(color)) return false;
            
            // Check if opponent has any pieces (not stalemate if one side has no pieces)
            var opponentColor = color === "white" ? "black" : "white";
            var opponentHasPieces = false;
            for (var i = 0; i < 8; i++) {
                for (var j = 0; j < 8; j++) {
                    if (chessBoard[i][j] && chessBoard[i][j].color === opponentColor) {
                        opponentHasPieces = true;
                        break;
                    }
                }
                if (opponentHasPieces) break;
            }
            
            if (!opponentHasPieces) return false; // Not stalemate if opponent has no pieces
            
            // Check if player has any legal moves that don't leave king in check
            for (var i = 0; i < 8; i++) {
                for (var j = 0; j < 8; j++) {
                    if (chessBoard[i][j] && chessBoard[i][j].color === color) {
                        var moves = chessGetValidMoves(i, j);
                        if (moves.length > 0) {
                            // Test each move to see if it leaves king safe
                            for (var m = 0; m < moves.length; m++) {
                                var testPiece = chessBoard[moves[m][0]][moves[m][1]];
                                chessBoard[moves[m][0]][moves[m][1]] = chessBoard[i][j];
                                chessBoard[i][j] = null;
                                
                                var stillInCheck = chessIsInCheck(color);
                                
                                chessBoard[i][j] = chessBoard[moves[m][0]][moves[m][1]];
                                chessBoard[moves[m][0]][moves[m][1]] = testPiece;
                                
                                if (!stillInCheck) {
                                    return false; // Found a legal move
                                }
                            }
                        }
                    }
                }
            }
            return true; // No legal moves and not in check = stalemate
        }

        function chessGetValidMovesRaw(row, col) {
            // Get moves without filtering for check (used for attack detection)
            var piece = chessBoard[row][col];
            if (!piece) return [];
            var moves = [];

            if (piece.type === "P") {
                var dir = piece.color === "white" ? -1 : 1;
                var startRow = piece.color === "white" ? 6 : 1;
                
                if (row + dir >= 0 && row + dir < 8 && chessBoard[row + dir][col] === null) {
                    moves.push([row + dir, col]);
                    if (row === startRow && chessBoard[row + dir*2][col] === null) {
                        moves.push([row + dir*2, col]);
                    }
                }
                
                if (col > 0 && row + dir >= 0 && row + dir < 8 && chessBoard[row + dir][col - 1] && chessBoard[row + dir][col - 1].color !== piece.color) {
                    moves.push([row + dir, col - 1]);
                }
                if (col < 7 && row + dir >= 0 && row + dir < 8 && chessBoard[row + dir][col + 1] && chessBoard[row + dir][col + 1].color !== piece.color) {
                    moves.push([row + dir, col + 1]);
                }
            } else if (piece.type === "N") {
                var knightMoves = [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
                for (var i = 0; i < knightMoves.length; i++) {
                    var nr = row + knightMoves[i][0];
                    var nc = col + knightMoves[i][1];
                    if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                        if (!chessBoard[nr][nc] || chessBoard[nr][nc].color !== piece.color) {
                            moves.push([nr, nc]);
                        }
                    }
                }
            } else if (piece.type === "B" || piece.type === "R" || piece.type === "Q") {
                var dirs = [];
                if (piece.type === "R" || piece.type === "Q") {
                    dirs = dirs.concat([[1,0],[-1,0],[0,1],[0,-1]]);
                }
                if (piece.type === "B" || piece.type === "Q") {
                    dirs = dirs.concat([[1,1],[1,-1],[-1,1],[-1,-1]]);
                }
                
                for (var d = 0; d < dirs.length; d++) {
                    for (var dist = 1; dist < 8; dist++) {
                        var nr = row + dirs[d][0] * dist;
                        var nc = col + dirs[d][1] * dist;
                        if (nr < 0 || nr >= 8 || nc < 0 || nc >= 8) break;
                        if (!chessBoard[nr][nc]) {
                            moves.push([nr, nc]);
                        } else {
                            if (chessBoard[nr][nc].color !== piece.color) {
                                moves.push([nr, nc]);
                            }
                            break;
                        }
                    }
                }
            } else if (piece.type === "K") {
                for (var i = -1; i <= 1; i++) {
                    for (var j = -1; j <= 1; j++) {
                        if (i === 0 && j === 0) continue;
                        var nr = row + i;
                        var nc = col + j;
                        if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                            if (!chessBoard[nr][nc] || chessBoard[nr][nc].color !== piece.color) {
                                moves.push([nr, nc]);
                            }
                        }
                    }
                }
            }

            return moves;
        }

        function chessBotMove(mode) {
            if (chessGameOver || chessCurrentPlayer !== "black") return;

            var validMoves = [];
            for (var i = 0; i < 8; i++) {
                for (var j = 0; j < 8; j++) {
                    if (chessBoard[i][j] && chessBoard[i][j].color === "black") {
                        var moves = chessGetValidMoves(i, j);
                        for (var k = 0; k < moves.length; k++) {
                            validMoves.push({from: [i, j], to: moves[k]});
                        }
                    }
                }
            }

            if (validMoves.length === 0) {
                chessGameOver = true;
                // Check if it's checkmate or stalemate
                if (chessIsInCheck("black")) {
                    chessStatusEl.innerHTML = "Checkmate! White wins!";
                } else {
                    chessStatusEl.innerHTML = "Stalemate! Draw!";
                }
                return;
            }

            var move;
            if (mode === "easy") {
                move = validMoves[Math.floor(Math.random() * validMoves.length)];
            } else {
                // Medium/Hard: prefer captures
                var captures = [];
                for (var i = 0; i < validMoves.length; i++) {
                    if (chessBoard[validMoves[i].to[0]][validMoves[i].to[1]]) {
                        captures.push(validMoves[i]);
                    }
                }
                move = captures.length > 0 ? captures[Math.floor(Math.random() * captures.length)] : validMoves[Math.floor(Math.random() * validMoves.length)];
            }

            var piece = chessBoard[move.from[0]][move.from[1]];
            var capturedPiece = chessBoard[move.to[0]][move.to[1]];
            
            // Check if pawn is promoting
            if (piece.type === "P" && move.to[0] === 7) {
                chessMove(move.from[0], move.from[1], move.to[0], move.to[1]);
                // Bot promotes to Queen (best piece)
                chessBoard[move.to[0]][move.to[1]].type = "Q";
            } else {
                chessMove(move.from[0], move.from[1], move.to[0], move.to[1]);
            }
            
            chessRender();
            
            // Check if King was captured
            if (capturedPiece && capturedPiece.type === "K") {
                chessGameOver = true;
                chessStatusEl.innerHTML = "King captured! Black wins!";
                return;
            }
            
            chessCurrentPlayer = "white";
            
            // Check if opponent (white) has any pieces left
            var whiteHasPieces = false;
            for (var i = 0; i < 8; i++) {
                for (var j = 0; j < 8; j++) {
                    if (chessBoard[i][j] && chessBoard[i][j].color === "white") {
                        whiteHasPieces = true;
                        break;
                    }
                }
                if (whiteHasPieces) break;
            }
            
            // If white has no pieces, black wins
            if (!whiteHasPieces) {
                chessGameOver = true;
                chessStatusEl.innerHTML = "Black wins! All white pieces captured!";
                return;
            }
            
            // Check for checkmate
            if (chessIsCheckmate(chessCurrentPlayer)) {
                chessGameOver = true;
                chessStatusEl.innerHTML = "Checkmate! Black wins!";
                return;
            }
            
            // Check if only kings remain (insufficient material = draw)
            if (chessOnlyKingsRemain()) {
                chessGameOver = true;
                chessStatusEl.innerHTML = "Draw! Only kings remaining (insufficient material)";
                return;
            }
            
            // Check for stalemate (only if white has pieces)
            if (whiteHasPieces && chessIsStalemate(chessCurrentPlayer)) {
                chessGameOver = true;
                chessStatusEl.innerHTML = "Stalemate! Draw!";
                return;
            }
            
            // Check for check
            if (chessIsInCheck(chessCurrentPlayer)) {
                chessStatusEl.innerHTML = "White is in Check!";
            } else {
                chessStatusEl.innerHTML = "White to move";
            }
        }

        function chessReset() {
            chessInit();
        }

        chessInit();

        // ==================== TETRIS GAME ====================
        const TETRIS_COLS = 10;
        const TETRIS_ROWS = 20;
        const BLOCK_SIZE = 30;

        let tetrisGrid = [];
        let tetrisScore = 0;
        let tetrisLevel = 1;
        let tetrisLines = 0;
        let tetrisPaused = false;
        let tetrisGameOver = false;
        let tetrisCurrentPiece = null;
        let tetrisNextPiece = null;
        let tetrisDropSpeed = 500;
        let tetrisDropTimer = null;
        let tetrisCanvas = document.getElementById('tetrisCanvas');
        let tetrisCtx = tetrisCanvas.getContext('2d');
        let tetrisNextCanvas = document.getElementById('tetrisNextCanvas');
        let tetrisNextCtx = tetrisNextCanvas.getContext('2d');

        const TETRIS_PIECES = [
            { name: 'I', shape: [[1,1,1,1]], color: '#00d4ff' },
            { name: 'O', shape: [[1,1],[1,1]], color: '#ffff00' },
            { name: 'T', shape: [[0,1,0],[1,1,1]], color: '#ff00ff' },
            { name: 'S', shape: [[0,1,1],[1,1,0]], color: '#00ff00' },
            { name: 'Z', shape: [[1,1,0],[0,1,1]], color: '#ff0000' },
            { name: 'J', shape: [[1,0,0],[1,1,1]], color: '#0000ff' },
            { name: 'L', shape: [[0,0,1],[1,1,1]], color: '#ff8800' }
        ];

        function tetrisGetRandomPiece() {
            return JSON.parse(JSON.stringify(TETRIS_PIECES[Math.floor(Math.random() * TETRIS_PIECES.length)]));
        }

        function tetrisInitGrid() {
            tetrisGrid = [];
            for (let i = 0; i < TETRIS_ROWS; i++) {
                tetrisGrid[i] = [];
                for (let j = 0; j < TETRIS_COLS; j++) {
                    tetrisGrid[i][j] = null;
                }
            }
        }

        function tetrisInit() {
            tetrisInitGrid();
            tetrisScore = 0;
            tetrisLevel = 1;
            tetrisLines = 0;
            tetrisPaused = false;
            tetrisGameOver = false;
            tetrisDropSpeed = 500;
            tetrisCurrentPiece = tetrisGetRandomPiece();
            tetrisCurrentPiece.x = Math.floor(TETRIS_COLS / 2) - 1;
            tetrisCurrentPiece.y = 0;
            tetrisNextPiece = tetrisGetRandomPiece();
            tetrisRender();
            tetrisRenderNext();
            tetrisStartDropTimer();
            document.getElementById('tetrisScore').innerHTML = tetrisScore;
            document.getElementById('tetrisLevel').innerHTML = tetrisLevel;
            document.getElementById('tetrisLines').innerHTML = tetrisLines;
        }

        function tetrisStartDropTimer() {
            if (tetrisDropTimer) clearInterval(tetrisDropTimer);
            tetrisDropTimer = setInterval(function() {
                if (!tetrisPaused && !tetrisGameOver) {
                    tetrisMovePieceDown();
                }
            }, tetrisDropSpeed);
        }

        function tetrisMovePieceDown() {
            if (!tetrisCanMovePiece(tetrisCurrentPiece, 0, 1)) {
                tetrisPlacePiece();
            } else {
                tetrisCurrentPiece.y++;
            }
            tetrisRender();
            tetrisRenderNext();
        }

        function tetrisCanMovePiece(piece, dx, dy) {
            for (let i = 0; i < piece.shape.length; i++) {
                for (let j = 0; j < piece.shape[i].length; j++) {
                    if (piece.shape[i][j]) {
                        let newX = piece.x + j + dx;
                        let newY = piece.y + i + dy;
                        if (newX < 0 || newX >= TETRIS_COLS || newY >= TETRIS_ROWS) return false;
                        if (newY >= 0 && tetrisGrid[newY][newX] !== null) return false;
                    }
                }
            }
            return true;
        }

        function tetrisPlacePiece() {
            for (let i = 0; i < tetrisCurrentPiece.shape.length; i++) {
                for (let j = 0; j < tetrisCurrentPiece.shape[i].length; j++) {
                    if (tetrisCurrentPiece.shape[i][j]) {
                        let x = tetrisCurrentPiece.x + j;
                        let y = tetrisCurrentPiece.y + i;
                        if (y >= 0) {
                            if (tetrisGrid[y][x] !== null) {
                                tetrisGameOver = true;
                                clearInterval(tetrisDropTimer);
                                return;
                            }
                            tetrisGrid[y][x] = tetrisCurrentPiece.color;
                        }
                    }
                }
            }
            tetrisClearLines();
            tetrisCurrentPiece = tetrisNextPiece;
            tetrisCurrentPiece.x = Math.floor(TETRIS_COLS / 2) - 1;
            tetrisCurrentPiece.y = 0;
            tetrisNextPiece = tetrisGetRandomPiece();
        }

        function tetrisClearLines() {
            let linesCleared = 0;
            for (let i = TETRIS_ROWS - 1; i >= 0; i--) {
                let isFull = true;
                for (let j = 0; j < TETRIS_COLS; j++) {
                    if (tetrisGrid[i][j] === null) {
                        isFull = false;
                        break;
                    }
                }
                if (isFull) {
                    tetrisGrid.splice(i, 1);
                    tetrisGrid.unshift(new Array(TETRIS_COLS).fill(null));
                    linesCleared++;
                    i++;
                }
            }
            if (linesCleared > 0) {
                tetrisLines += linesCleared;
                tetrisScore += linesCleared * 100 * tetrisLevel;
                tetrisLevel = Math.floor(tetrisLines / 10) + 1;
                tetrisDropSpeed = Math.max(100, 500 - (tetrisLevel - 1) * 50);
                tetrisStartDropTimer();
                document.getElementById('tetrisScore').innerHTML = tetrisScore;
                document.getElementById('tetrisLevel').innerHTML = tetrisLevel;
                document.getElementById('tetrisLines').innerHTML = tetrisLines;
            }
        }

        function tetrisRotatePiece() {
            let newShape = [];
            for (let j = 0; j < tetrisCurrentPiece.shape[0].length; j++) {
                let row = [];
                for (let i = tetrisCurrentPiece.shape.length - 1; i >= 0; i--) {
                    row.push(tetrisCurrentPiece.shape[i][j]);
                }
                newShape.push(row);
            }
            let oldShape = tetrisCurrentPiece.shape;
            tetrisCurrentPiece.shape = newShape;
            if (!tetrisCanMovePiece(tetrisCurrentPiece, 0, 0)) {
                tetrisCurrentPiece.shape = oldShape;
            }
            tetrisRender();
            tetrisRenderNext();
        }

        function tetrisRender() {
            tetrisCtx.fillStyle = '#000';
            tetrisCtx.fillRect(0, 0, tetrisCanvas.width, tetrisCanvas.height);

            // Draw grid lines
            tetrisCtx.strokeStyle = '#1a2238';
            tetrisCtx.lineWidth = 0.5;
            for (let i = 0; i <= TETRIS_ROWS; i++) {
                tetrisCtx.beginPath();
                tetrisCtx.moveTo(0, i * BLOCK_SIZE);
                tetrisCtx.lineTo(tetrisCanvas.width, i * BLOCK_SIZE);
                tetrisCtx.stroke();
            }
            for (let j = 0; j <= TETRIS_COLS; j++) {
                tetrisCtx.beginPath();
                tetrisCtx.moveTo(j * BLOCK_SIZE, 0);
                tetrisCtx.lineTo(j * BLOCK_SIZE, tetrisCanvas.height);
                tetrisCtx.stroke();
            }

            // Draw placed blocks
            for (let i = 0; i < tetrisGrid.length; i++) {
                for (let j = 0; j < tetrisGrid[i].length; j++) {
                    if (tetrisGrid[i][j]) {
                        tetrisCtx.fillStyle = tetrisGrid[i][j];
                        tetrisCtx.fillRect(j * BLOCK_SIZE + 1, i * BLOCK_SIZE + 1, BLOCK_SIZE - 2, BLOCK_SIZE - 2);
                        tetrisCtx.strokeStyle = '#fff';
                        tetrisCtx.lineWidth = 1;
                        tetrisCtx.strokeRect(j * BLOCK_SIZE + 1, i * BLOCK_SIZE + 1, BLOCK_SIZE - 2, BLOCK_SIZE - 2);
                    }
                }
            }

            // Draw ghost piece (where piece will land)
            if (tetrisCurrentPiece) {
                let ghostY = tetrisCurrentPiece.y;
                // Calculate landing position
                while (tetrisCanMovePiece({
                    shape: tetrisCurrentPiece.shape,
                    x: tetrisCurrentPiece.x,
                    y: ghostY,
                    color: tetrisCurrentPiece.color
                }, 0, 1)) {
                    ghostY++;
                }
                
                tetrisCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                tetrisCtx.lineWidth = 2;
                for (let i = 0; i < tetrisCurrentPiece.shape.length; i++) {
                    for (let j = 0; j < tetrisCurrentPiece.shape[i].length; j++) {
                        if (tetrisCurrentPiece.shape[i][j]) {
                            let x = (tetrisCurrentPiece.x + j) * BLOCK_SIZE;
                            let y = (ghostY + i) * BLOCK_SIZE;
                            tetrisCtx.strokeRect(x + 1, y + 1, BLOCK_SIZE - 2, BLOCK_SIZE - 2);
                        }
                    }
                }
            }

            // Draw current piece
            if (tetrisCurrentPiece) {
                tetrisCtx.fillStyle = tetrisCurrentPiece.color;
                for (let i = 0; i < tetrisCurrentPiece.shape.length; i++) {
                    for (let j = 0; j < tetrisCurrentPiece.shape[i].length; j++) {
                        if (tetrisCurrentPiece.shape[i][j]) {
                            let x = (tetrisCurrentPiece.x + j) * BLOCK_SIZE;
                            let y = (tetrisCurrentPiece.y + i) * BLOCK_SIZE;
                            tetrisCtx.fillRect(x + 1, y + 1, BLOCK_SIZE - 2, BLOCK_SIZE - 2);
                            tetrisCtx.strokeStyle = '#fff';
                            tetrisCtx.lineWidth = 1;
                            tetrisCtx.strokeRect(x + 1, y + 1, BLOCK_SIZE - 2, BLOCK_SIZE - 2);
                        }
                    }
                }
            }

            if (tetrisGameOver) {
                tetrisCtx.fillStyle = 'rgba(255, 75, 129, 0.7)';
                tetrisCtx.fillRect(0, 0, tetrisCanvas.width, tetrisCanvas.height);
                tetrisCtx.fillStyle = '#fff';
                tetrisCtx.font = 'bold 40px Arial';
                tetrisCtx.textAlign = 'center';
                tetrisCtx.fillText('GAME OVER', tetrisCanvas.width / 2, tetrisCanvas.height / 2 - 20);
                tetrisCtx.font = '20px Arial';
                tetrisCtx.fillText('Score: ' + tetrisScore, tetrisCanvas.width / 2, tetrisCanvas.height / 2 + 20);
            }
        }

        function tetrisRenderNext() {
            tetrisNextCtx.fillStyle = '#000';
            tetrisNextCtx.fillRect(0, 0, tetrisNextCanvas.width, tetrisNextCanvas.height);
            tetrisNextCtx.fillStyle = tetrisNextPiece.color;
            let offsetX = (tetrisNextCanvas.width - tetrisNextPiece.shape[0].length * 20) / 2;
            let offsetY = (tetrisNextCanvas.height - tetrisNextPiece.shape.length * 20) / 2;
            for (let i = 0; i < tetrisNextPiece.shape.length; i++) {
                for (let j = 0; j < tetrisNextPiece.shape[i].length; j++) {
                    if (tetrisNextPiece.shape[i][j]) {
                        tetrisNextCtx.fillRect(offsetX + j * 20 + 2, offsetY + i * 20 + 2, 16, 16);
                    }
                }
            }
        }

        function tetrisReset() {
            tetrisInit();
        }

        // Keyboard controls
        document.addEventListener('keydown', function(e) {
            if (tetrisGameOver || !document.getElementById('game-tetris') || document.getElementById('game-tetris').style.display === 'none') return;
            if (tetrisPaused) return;
            
            if (e.key === 'ArrowLeft') {
                if (tetrisCanMovePiece(tetrisCurrentPiece, -1, 0)) tetrisCurrentPiece.x--;
                tetrisRender();
                tetrisRenderNext();
            } else if (e.key === 'ArrowRight') {
                if (tetrisCanMovePiece(tetrisCurrentPiece, 1, 0)) tetrisCurrentPiece.x++;
                tetrisRender();
                tetrisRenderNext();
            } else if (e.key === 'ArrowDown') {
                tetrisMovePieceDown();
            } else if (e.key === 'ArrowUp') {
                tetrisRotatePiece();
            }
        });

        // Touch/Gesture controls for mobile
        let tetrisTouchStartX = 0;
        let tetrisTouchStartY = 0;

        tetrisCanvas.addEventListener('touchstart', function(e) {
            tetrisTouchStartX = e.touches[0].clientX;
            tetrisTouchStartY = e.touches[0].clientY;
        }, false);

        tetrisCanvas.addEventListener('touchmove', function(e) {
            e.preventDefault();
        }, false);

        tetrisCanvas.addEventListener('touchend', function(e) {
            if (tetrisGameOver || tetrisPaused) return;
            
            let touchEndX = e.changedTouches[0].clientX;
            let touchEndY = e.changedTouches[0].clientY;
            let diffX = touchStartX - touchEndX;
            let diffY = touchEndY - tetrisTouchStartY;

            if (Math.abs(diffX) > Math.abs(diffY)) {
                // Horizontal swipe
                if (diffX > 30) {
                    // Swipe left
                    if (tetrisCanMovePiece(tetrisCurrentPiece, -1, 0)) tetrisCurrentPiece.x--;
                } else if (diffX < -30) {
                    // Swipe right
                    if (tetrisCanMovePiece(tetrisCurrentPiece, 1, 0)) tetrisCurrentPiece.x++;
                }
            } else {
                // Vertical swipe
                if (diffY > 30) {
                    // Swipe down - move down faster
                    tetrisMovePieceDown();
                    tetrisMovePieceDown();
                }
            }
            tetrisRender();
            tetrisRenderNext();
        }, false);


        // ==================== CODEBREAKER GAME ====================
        let codebreaker_code = '';
        let codebreaker_attempts = 5;
        let codebreaker_revealed = false;
        let codebreaker_guesses = [];
        let codebreaker_length = 4;
        let codebreaker_difficulty = 'normal';

        function codebreaker_generateCode(length) {
            codebreaker_code = '';
            for (let i = 0; i < length; i++) {
                codebreaker_code += Math.floor(Math.random() * 10);
            }
        }

        function codebreaker_start_game(difficulty) {
            if (difficulty === 'easy') {
                codebreaker_length = 3;
                codebreaker_attempts = 5;
                codebreaker_difficulty = 'easy';
            } else if (difficulty === 'normal') {
                codebreaker_length = 4;
                codebreaker_attempts = 5;
                codebreaker_difficulty = 'normal';
            } else if (difficulty === 'hard') {
                codebreaker_length = 5;
                codebreaker_attempts = 5;
                codebreaker_difficulty = 'hard';
            }

            codebreaker_generateCode(codebreaker_length);
            codebreaker_revealed = false;
            codebreaker_guesses = [];

            document.getElementById('codebreaker-difficulty-select').style.display = 'none';
            document.getElementById('codebreaker-game').style.display = 'flex';
            document.getElementById('codebreaker-difficulty-display').textContent = difficulty.toUpperCase();
            document.getElementById('codebreaker-secret').textContent = '?'.repeat(codebreaker_length);
            document.getElementById('codebreaker-attempts').textContent = codebreaker_attempts;
            document.getElementById('codebreaker-history').innerHTML = '<div style="color: var(--text-soft); font-size: 13px; text-align: center; padding: 20px;">No guesses yet</div>';

            // Generate single input field
            let inputGroup = document.getElementById('codebreaker-input-group');
            inputGroup.innerHTML = `<div style="margin-bottom: 15px;">
                <input type="text" id="codebreaker-input" placeholder="Enter ${codebreaker_length}-digit code" maxlength="${codebreaker_length}" style="background: var(--bg-elevated); border: 1px solid var(--border-subtle); color: var(--text-main); text-align: center; font-size: 24px; padding: 12px; border-radius: 4px; width: 100%; font-family: monospace; letter-spacing: 8px;" />
            </div><button class="btn-small" onclick="codebreaker_submit()" style="width: 100%; margin-bottom: 20px;">Submit Guess</button>`;
        }

        function codebreaker_submit() {
            if (codebreaker_attempts <= 0 || codebreaker_revealed) return;
            
            let guess = document.getElementById('codebreaker-input').value.trim();

            if (guess.length !== codebreaker_length || isNaN(guess)) {
                alert('Please enter a valid ' + codebreaker_length + '-digit code');
                return;
            }

            codebreaker_guesses.push(guess);
            codebreaker_attempts--;

            // Calculate feedback per digit
            let feedback = [];
            let codeArray = codebreaker_code.split('');
            let guessArray = guess.split('');
            let usedCode = new Array(codebreaker_length).fill(false);
            let usedGuess = new Array(codebreaker_length).fill(false);

            // First pass: mark correct positions
            for (let i = 0; i < codebreaker_length; i++) {
                if (guessArray[i] === codeArray[i]) {
                    feedback[i] = '✓';
                    usedCode[i] = true;
                    usedGuess[i] = true;
                }
            }

            // Second pass: mark wrong positions
            for (let i = 0; i < codebreaker_length; i++) {
                if (!usedGuess[i]) {
                    let found = false;
                    for (let j = 0; j < codebreaker_length; j++) {
                        if (!usedCode[j] && guessArray[i] === codeArray[j]) {
                            feedback[i] = '⊙';
                            usedCode[j] = true;
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        feedback[i] = '✕';
                    }
                }
            }

            // Build display
            let guessDisplay = '';
            for (let i = 0; i < codebreaker_length; i++) {
                guessDisplay += `<span style="display: inline-block; width: 35px; text-align: center; color: var(--text-soft); font-family: monospace; font-size: 16px; font-weight: 700;">${guessArray[i]}</span>`;
            }

            let feedbackDisplay = '';
            for (let i = 0; i < codebreaker_length; i++) {
                let symbol = feedback[i];
                let color = symbol === '✓' ? '#00ff88' : (symbol === '⊙' ? '#ffaa00' : '#ff6b6b');
                feedbackDisplay += `<span style="display: inline-block; width: 35px; text-align: center; color: ${color}; font-size: 18px; font-weight: 900;">[${symbol}]</span>`;
            }

            let result = `<div style="padding: 10px; background: var(--bg-main); border: 1px solid var(--border-subtle); border-radius: 4px; margin-bottom: 8px;">
                <div style="margin-bottom: 8px;">${guessDisplay}</div>
                <div>${feedbackDisplay}</div>
            </div>`;

            let historyEl = document.getElementById('codebreaker-history');
            if (historyEl.innerHTML.includes('No guesses yet')) {
                historyEl.innerHTML = result;
            } else {
                historyEl.innerHTML = result + historyEl.innerHTML;
            }

            document.getElementById('codebreaker-attempts').textContent = codebreaker_attempts;

            // Check if all digits are correct
            let allCorrect = feedback.every(f => f === '✓');
            
            if (allCorrect) {
                setTimeout(() => {
                    alert('🎉 You cracked the code! ' + codebreaker_code);
                    codebreaker_revealed = true;
                    document.getElementById('codebreaker-secret').textContent = codebreaker_code;
                }, 100);
            } else if (codebreaker_attempts === 0) {
                codebreaker_revealed = true;
                document.getElementById('codebreaker-secret').textContent = codebreaker_code;
                alert('Game Over! The code was: ' + codebreaker_code);
            }

            // Clear input
            document.getElementById('codebreaker-input').value = '';
        }

        function codebreaker_reset() {
            document.getElementById('codebreaker-game').style.display = 'none';
            document.getElementById('codebreaker-difficulty-select').style.display = 'flex';
        }

        function codebreaker_reveal() {
            codebreaker_revealed = true;
            document.getElementById('codebreaker-secret').textContent = codebreaker_code;
        }

        // Allow Enter key to submit
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && document.getElementById('game-codebreaker') && document.getElementById('game-codebreaker').style.display !== 'none' && document.getElementById('codebreaker-game').style.display !== 'none') {
                codebreaker_submit();
            }
        });

        // ==================== GRID GAME ====================
        let gridgame_grid = [];
        let gridgame_player = { x: 0, y: 0 };
        let gridgame_item = { x: 0, y: 0 };
        let gridgame_hazards = [];
        let gridgame_score = 0;
        let gridgame_gameOver = false;
        let gridgame_won = false;
        let gridgame_difficulty = 'normal';
        let gridgame_max_hazards = 16;

        function gridgame_change_difficulty() {
            let selected = document.getElementById('gridgame-difficulty').value;
            if (selected === 'easy') {
                gridgame_max_hazards = 8;
            } else if (selected === 'normal') {
                gridgame_max_hazards = 16;
            } else if (selected === 'hard') {
                gridgame_max_hazards = 32;
            }
            gridgame_reset();
        }

        function gridgame_reset() {
            gridgame_grid = [];
            for (let i = 0; i < 8; i++) {
                gridgame_grid[i] = [];
                for (let j = 0; j < 8; j++) {
                    gridgame_grid[i][j] = '.';
                }
            }
            gridgame_player = { x: 0, y: 0 };
            gridgame_hazards = [];
            gridgame_score = 0;
            gridgame_gameOver = false;
            gridgame_won = false;
            
            document.getElementById('gridgame-status').textContent = 'PLAYING';
            document.getElementById('gridgame-status').style.color = 'var(--accent)';
            
            gridgame_generateItem();
            gridgame_render();
        }

        function gridgame_generateItem() {
            let validPosition = false;
            while (!validPosition) {
                gridgame_item = { 
                    x: Math.floor(Math.random() * 8), 
                    y: Math.floor(Math.random() * 8) 
                };
                if ((gridgame_item.x !== gridgame_player.x || gridgame_item.y !== gridgame_player.y) &&
                    !gridgame_hazards.some(h => h.x === gridgame_item.x && h.y === gridgame_item.y)) {
                    validPosition = true;
                }
            }
        }

        function gridgame_addHazard() {
            if (gridgame_hazards.length >= gridgame_max_hazards) return;
            
            let validPosition = false;
            let attempts = 0;
            while (!validPosition && attempts < 50) {
                let x = Math.floor(Math.random() * 8);
                let y = Math.floor(Math.random() * 8);
                
                if ((x !== gridgame_player.x || y !== gridgame_player.y) &&
                    (x !== gridgame_item.x || y !== gridgame_item.y) &&
                    !gridgame_hazards.some(h => h.x === x && h.y === y)) {
                    
                    // Check if item is still reachable
                    let tempHazards = [...gridgame_hazards, { x, y }];
                    if (gridgame_isItemReachable(tempHazards)) {
                        gridgame_hazards.push({ x, y });
                        validPosition = true;
                    }
                }
                attempts++;
            }
        }

        function gridgame_isItemReachable(hazards) {
            // BFS to check if item is reachable from player
            let visited = new Array(8).fill(0).map(() => new Array(8).fill(false));
            let queue = [{ x: gridgame_player.x, y: gridgame_player.y }];
            visited[gridgame_player.y][gridgame_player.x] = true;
            
            while (queue.length > 0) {
                let { x, y } = queue.shift();
                
                if (x === gridgame_item.x && y === gridgame_item.y) {
                    return true;
                }
                
                // Check all 4 directions
                let directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                for (let [dx, dy] of directions) {
                    let nx = x + dx, ny = y + dy;
                    if (nx >= 0 && nx < 8 && ny >= 0 && ny < 8 && !visited[ny][nx]) {
                        let isHazard = hazards.some(h => h.x === nx && h.y === ny);
                        if (!isHazard) {
                            visited[ny][nx] = true;
                            queue.push({ x: nx, y: ny });
                        }
                    }
                }
            }
            return false;
        }

        function gridgame_movePlayer(dx, dy) {
            if (gridgame_gameOver || gridgame_won) return;
            
            let newX = gridgame_player.x + dx;
            let newY = gridgame_player.y + dy;
            
            if (newX >= 0 && newX < 8 && newY >= 0 && newY < 8) {
                // Check if hitting hazard
                if (gridgame_hazards.some(h => h.x === newX && h.y === newY)) {
                    gridgame_gameOver = true;
                    document.getElementById('gridgame-status').textContent = 'LOST';
                    document.getElementById('gridgame-status').style.color = '#ff6b6b';
                    alert('💀 Hit a hazard! Game Over!');
                    gridgame_render();
                    return;
                }
                
                gridgame_player.x = newX;
                gridgame_player.y = newY;
                
                // Check if collected item
                if (gridgame_player.x === gridgame_item.x && gridgame_player.y === gridgame_item.y) {
                    gridgame_score += 1;
                    
                    // Add hazard every 10 points
                    if (gridgame_score % 10 === 0 && gridgame_hazards.length < gridgame_max_hazards) {
                        gridgame_addHazard();
                    }
                    
                    // Check win condition
                    if (gridgame_hazards.length >= gridgame_max_hazards) {
                        gridgame_won = true;
                        document.getElementById('gridgame-status').textContent = 'WON!';
                        document.getElementById('gridgame-status').style.color = '#00ff88';
                        alert('🎉 You won! All ' + gridgame_max_hazards + ' hazards collected!');
                        gridgame_render();
                        return;
                    }
                    
                    gridgame_generateItem();
                }
                
                gridgame_render();
            }
        }

        function gridgame_render() {
            // Clear grid
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    gridgame_grid[i][j] = '.';
                }
            }
            
            // Place hazards
            for (let h of gridgame_hazards) {
                gridgame_grid[h.y][h.x] = '#';
            }
            
            // Place item
            gridgame_grid[gridgame_item.y][gridgame_item.x] = '$';
            
            // Place player
            gridgame_grid[gridgame_player.y][gridgame_player.x] = '@';
            
            // Render to HTML
            let gridEl = document.getElementById('gridgame-grid');
            gridEl.innerHTML = '';
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    let cell = document.createElement('div');
                    let char = gridgame_grid[i][j];
                    cell.textContent = char;
                    cell.style.cssText = `
                        aspect-ratio: 1;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        background: ${char === '@' ? 'rgba(0, 180, 255, 0.2)' : (char === '$' ? 'rgba(255, 200, 0, 0.2)' : (char === '#' ? 'rgba(255, 75, 129, 0.2)' : 'rgba(255,255,255,0.05)'))};
                        border: 1px solid var(--border-subtle);
                        border-radius: 2px;
                        font-weight: 700;
                        font-size: 16px;
                        color: ${char === '@' ? '#00b4ff' : (char === '$' ? '#ffc800' : (char === '#' ? '#ff4b81' : 'transparent'))};
                    `;
                    gridEl.appendChild(cell);
                }
            }
            
            // Update stats
            document.getElementById('gridgame-score').textContent = gridgame_score;
            document.getElementById('gridgame-hazards').textContent = gridgame_hazards.length + '/' + gridgame_max_hazards;
        }

        // Keyboard controls
        document.addEventListener('keydown', function(e) {
            if (!document.getElementById('game-gridgame') || document.getElementById('game-gridgame').style.display === 'none') return;
            
            if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
                gridgame_movePlayer(0, -1);
            } else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') {
                gridgame_movePlayer(0, 1);
            } else if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                gridgame_movePlayer(-1, 0);
            } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                gridgame_movePlayer(1, 0);
            }
        });

        // Touch controls
        let gridgame_touchStartX = 0;
        let gridgame_touchStartY = 0;
        let gridgameGridEl = document.getElementById('gridgame-grid');
        
        if (gridgameGridEl) {
            gridgameGridEl.addEventListener('touchstart', function(e) {
                gridgame_touchStartX = e.touches[0].clientX;
                gridgame_touchStartY = e.touches[0].clientY;
            }, false);

            gridgameGridEl.addEventListener('touchend', function(e) {
                let touchEndX = e.changedTouches[0].clientX;
                let touchEndY = e.changedTouches[0].clientY;
                let diffX = gridgame_touchStartX - touchEndX;
                let diffY = gridgame_touchStartY - touchEndY;

                if (Math.abs(diffX) > Math.abs(diffY)) {
                    if (diffX > 30) {
                        gridgame_movePlayer(-1, 0); // Left
                    } else if (diffX < -30) {
                        gridgame_movePlayer(1, 0); // Right
                    }
                } else {
                    if (diffY > 30) {
                        gridgame_movePlayer(0, 1); // Down
                    } else if (diffY < -30) {
                        gridgame_movePlayer(0, -1); // Up
                    }
                }
            }, false);
        }

        // Initialize chat with welcome message
        setTimeout(function() {
            addChatMessage("Welcome to HyperZAI! Ask me anything, do math calculations, or search for information.", "bot");
        }, 100);

        // ==================== HACKER SIMULATOR ====================
        let hackersim_bitcoin = 0;
        let hackersim_power = 1;
        let hackersim_computers_hacked = 0;
        let hackersim_password = '';
        let hackersim_password_length = 4;
        let hackersim_crack_in_progress = false;
        const hackersim_chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';

        function hackersim_reset() {
            hackersim_bitcoin = 0;
            hackersim_power = 1;
            hackersim_computers_hacked = 0;
            hackersim_password_length = 4;
            hackersim_crack_in_progress = false;
            hackersim_generate_password();
            hackersim_render_main_menu();
            hackersim_update_display();
        }

        function hackersim_generate_password() {
            hackersim_password = '';
            for (let i = 0; i < hackersim_password_length; i++) {
                hackersim_password += hackersim_chars.charAt(Math.floor(Math.random() * hackersim_chars.length));
            }
        }

        function hackersim_update_display() {
            document.getElementById('hackersim-bitcoin').textContent = hackersim_bitcoin.toFixed(3);
            document.getElementById('hackersim-power').textContent = hackersim_power;
            document.getElementById('hackersim-hacked').textContent = hackersim_computers_hacked;
            document.getElementById('hackersim-password-display').textContent = '●'.repeat(hackersim_password_length);
            
            let upgrade_cost = (0.5 + (hackersim_power - 1) * 0.1).toFixed(1);
            document.getElementById('hackersim-upgrade-cost').textContent = upgrade_cost + ' BTC';
            document.getElementById('hackersim-balance-display').textContent = hackersim_bitcoin.toFixed(3) + ' BTC';
            
            let can_afford = hackersim_bitcoin >= parseFloat(upgrade_cost);
            document.getElementById('hackersim-upgrade-btn').style.opacity = can_afford ? '1' : '0.5';
            document.getElementById('hackersim-upgrade-btn').style.pointerEvents = can_afford ? 'auto' : 'none';
        }

        function hackersim_render_main_menu() {
            document.getElementById('hackersim-main-menu').style.display = 'flex';
            document.getElementById('hackersim-enter-menu').style.display = 'none';
            document.getElementById('hackersim-crack-menu').style.display = 'none';
            document.getElementById('hackersim-upgrade-menu').style.display = 'none';
        }

        function hackersim_enter_password_menu() {
            document.getElementById('hackersim-main-menu').style.display = 'none';
            document.getElementById('hackersim-enter-menu').style.display = 'flex';
            document.getElementById('hackersim-password-input').value = '';
            document.getElementById('hackersim-password-input').focus();
        }

        function hackersim_upgrade_menu() {
            document.getElementById('hackersim-main-menu').style.display = 'none';
            document.getElementById('hackersim-upgrade-menu').style.display = 'flex';
        }

        function hackersim_back_menu() {
            hackersim_render_main_menu();
        }

        function hackersim_submit_password() {
            let input = document.getElementById('hackersim-password-input').value.toUpperCase();
            
            if (input === hackersim_password) {
                alert('✓ Access granted! Injecting miner...');
                hackersim_computers_hacked++;
                if (hackersim_password_length < 32) {
                    hackersim_password_length++;
                }
                hackersim_generate_password();
                hackersim_render_main_menu();
                hackersim_update_display();
            } else {
                alert('✗ Incorrect password! Try again.');
                document.getElementById('hackersim-password-input').value = '';
                document.getElementById('hackersim-password-input').focus();
            }
        }

        function hackersim_start_crack() {
            if (hackersim_crack_in_progress) return;
            
            hackersim_crack_in_progress = true;
            document.getElementById('hackersim-main-menu').style.display = 'none';
            document.getElementById('hackersim-crack-menu').style.display = 'flex';
            document.getElementById('hackersim-copy-btn').style.display = 'none';
            
            let crack_time = hackersim_password_length / Math.pow(1.2, hackersim_power - 1);
            let elapsed = 0;
            let start_time = Date.now();
            
            let timer = setInterval(function() {
                elapsed = (Date.now() - start_time) / 1000;
                document.getElementById('hackersim-crack-timer').textContent = elapsed.toFixed(2) + 's';
                document.getElementById('hackersim-crack-status').textContent = 'Time remaining: ' + Math.max(0, crack_time - elapsed).toFixed(2) + 's';
                
                if (elapsed >= crack_time) {
                    clearInterval(timer);
                    document.getElementById('hackersim-crack-timer').textContent = crack_time.toFixed(2) + 's';
                    document.getElementById('hackersim-crack-status').textContent = 'Password: ' + hackersim_password;
                    document.getElementById('hackersim-crack-status').style.color = '#00ff88';
                    document.getElementById('hackersim-copy-btn').style.display = 'block';
                }
            }, 50);
        }

        function hackersim_copy_password() {
            navigator.clipboard.writeText(hackersim_password).then(function() {
                alert('✓ Password copied to clipboard!');
                document.getElementById('hackersim-copy-btn').textContent = 'Password Copied!';
                document.getElementById('hackersim-password-display').textContent = hackersim_password;
                setTimeout(function() {
                    document.getElementById('hackersim-copy-btn').textContent = 'Copy Password';
                    hackersim_crack_in_progress = false;
                    hackersim_enter_password_menu();
                }, 1000);
            }).catch(function(err) {
                alert('Failed to copy password');
                console.error(err);
            });
        }

        function hackersim_collect_bitcoin() {
            if (hackersim_computers_hacked === 0) {
                alert('You must hack at least 1 computer first!');
                return;
            }
            
            let earned = 0.001 * hackersim_computers_hacked * hackersim_power;
            hackersim_bitcoin += earned;
            alert('💰 Collected ' + earned.toFixed(3) + ' BTC!');
            hackersim_update_display();
        }

        function hackersim_confirm_upgrade() {
            let upgrade_cost = 0.5 + (hackersim_power - 1) * 0.1;
            
            if (hackersim_bitcoin < upgrade_cost) {
                alert('Not enough Bitcoin! Need ' + upgrade_cost.toFixed(1) + ' BTC');
                return;
            }
            
            hackersim_bitcoin -= upgrade_cost;
            hackersim_power++;
            alert('⚡ Power upgraded to ' + hackersim_power + '!');
            hackersim_render_main_menu();
            hackersim_update_display();
        }

        // Enter key to submit password
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && document.getElementById('hackersim-password-input').style.display !== 'none') {
                let parent = document.getElementById('hackersim-password-input').parentElement;
                if (parent && parent.style.display !== 'none') {
                    hackersim_submit_password();
                }
            }
        });
    </script>
</body>
</html>
